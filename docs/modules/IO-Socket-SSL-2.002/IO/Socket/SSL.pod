
=encoding utf-8

=head1 NAME

=begin original

IO::Socket::SSL - SSL sockets with IO::Socket interface

=end original

IO::Socket::SSL - IO::Socket インターフェースの SSL ソケット

(訳注: (TBR)がついている段落は「みんなの自動翻訳＠TexTra」による
機械翻訳です。)

=head1 SYNOPSIS

    use strict;
    use IO::Socket::SSL;

    # simple client
    my $cl = IO::Socket::SSL->new('www.google.com:443');
    print $cl "GET / HTTP/1.0\r\n\r\n";
    print <$cl>;

    # simple server
    my $srv = IO::Socket::SSL->new(
	LocalAddr => '0.0.0.0:1234',
	Listen => 10,
	SSL_cert_file => 'server-cert.pem',
	SSL_key_file => 'server-key.pem',
    );
    $srv->accept;

=head1 DESCRIPTION

=begin original

IO::Socket::SSL makes using SSL/TLS much easier by wrapping the necessary
functionality into the familiar L<IO::Socket> interface and providing secure
defaults whenever possible.
This way existing applications can be made SSL-aware without much effort, at
least if you do blocking I/O and don't use select or poll.

=end original

IO::Socket::SSLを使用すると、必要な機能を使い慣れたL<IO::Socket>インターフェイスにラップし、可能な限り安全なデフォルトを提供することで、SSL/TLSの使用がはるかに簡単になります。
この方法により、少なくともI/Oをブロックし、selectやpollを使用しない場合は、既存のアプリケーションをそれほど手間をかけずにSSL対応にすることができます。
(TBR)

=begin original

But, under the hood SSL is a complex beast.
So there are lots of methods to make it do what you need if the default
behavior is not adequate.
Because it is easy to inadvertently introduce critical security bugs or just
getting hard to debug problems, I would recommend to study the following
documentation carefully.

=end original

しかし、SSLの内部は複雑なものです。
そのため、デフォルトの動作が適切でない場合に必要なことを実行させるための方法はたくさんあります。
重大なセキュリティバグを不注意に導入したり、問題のデバッグが困難になったりすることがよくあるので、以下の文書を注意深く調べることをお勧めします。
(TBR)

=begin original

The documentation consists of the following parts:

=end original

このマニュアルは、次の部分で構成されています。
(TBR)

=over 4

=item * L</"Essential Information About SSL/TLS">

=item * L</"Basic SSL Client">

=item * L</"Basic SSL Server">

=item * L</"Common Usage Errors">

=item * L</"Common Problems with SSL">

=item * L</"Using Non-Blocking Sockets">

=item * L</"Advanced Usage">

=item * L</"Integration Into Own Modules">

=item * L</"Description Of Methods">

=back

=begin original

Additional documentation can be found in

=end original

その他のマニュアルについては、を参照してください。
(TBR)

=over 4

=item * L<IO::Socket::SSL::Intercept> - Doing Man-In-The-Middle with SSL

=item * L<IO::Socket::SSL::Utils> - Useful functions for certificates etc

=back

=head1 Essential Information About SSL/TLS

=begin original

SSL (Secure Socket Layer) or its successor TLS (Transport Layer Security) are
protocols to facilitate end-to-end security. These protocols are used when
accessing web sites (https), delivering or retrieving email and in lots of other
use cases.
In the following we will only talk use the name SSL, but means SSL and TLS.

=end original

SSL(Secure Socket Layer)またはその後継であるTLS(Transport Layer Security)は、エンドツーエンドのセキュリティを促進するプロトコルです。
これらのプロトコルは、Webサイト(https)へのアクセス、電子メールの配信または取得、およびその他の多くのユースケースで使用されます。
以下では、SSLという名前のみを使用しますが、SSLとTLSを意味します。
(TBR)

=begin original

SSL enables end-to-end security by providing two essential functions:

=end original

SSLは、次の2つの重要な機能を提供することにより、エンドツーエンドのセキュリティを実現します。
(TBR)

=over 4

=item Encryption

=begin original

This part encrypts the data for transit between the communicating parties, so
that nobody in between can read them. It also provides tamper resistance so that
nobody in between can manipulate the data.

=end original

この部分は、通信者間の転送のためにデータを暗号化し、通信者間で誰もデータを読み取ることができないようにします。
また、通信者間で誰もデータを操作できないように耐タンパー性を提供します。
(TBR)

=item Identification

=begin original

This part makes sure that you talk to the right peer.
If the identification is done wrong it is easy to mount man-in-the-middle
attacks, e.g. if Alice wants to talk to Bob it would be possible for Mallory to
put itself in the middle, so that Alice talks to Mallory and Mallory to Bob.
All the data would still be encrypted, but not end-to-end between Alice and Bob,
but only between Alice and Mallory and then between Mallory and Bob.
Thus Mallory would be able to read and modify all traffic between Alice and Bob.

=end original

この部分では、適切なピアと通信するようにします。
識別が間違っている場合、中間者攻撃を仕掛けるのは簡単です。
たとえば、アリスがボブと通信したい場合、マロリーが自身を中間に配置して、アリスがマロリーと通信し、マロリーがボブと通信するようにすることができます。
すべてのデータは暗号化されますが、アリスとボブの間のエンドツーエンドではなく、アリスとマロリーの間、そしてマロリーとボブの間でのみ暗号化されます。
したがって、マロリーはアリスとボブの間のすべてのトラフィックを読み取り、変更することができます。
(TBR)

=back

=begin original

Identification is the part which is the hardest to understand and the easiest
to get wrong.

=end original

識別は、最も理解しにくく、最も間違えやすい部分です。
(TBR)

=begin original

With SSL the Identification is usually done with B<certificates> inside a B<PKI>
(Public Key Infrastructure).
These Certificates are comparable to an identity card, which contains
information about the owner of the card. The card then is somehow B<signed> by
the B<issuer> of the card, the B<CA> (Certificate Agency).

=end original

SSLでは、識別は通常、B<PKI>(公開鍵インフラストラクチャ)内のB<証明書>で行われます。
これらの証明書は、カードの所有者に関する情報を含むIDカードに相当します。
カードは、カードのB<発行者>であるB<CA>(認証局)によって何らかの形でB<署名>されます。
(TBR)

=begin original

To verify the identity of the peer the following must be done inside SSL:

=end original

ピアのIDを確認するには、SSL内で次の手順を実行する必要があります。
(TBR)

=over 4

=item *

=begin original

Get the certificate from the peer.
If the peer does not present a certificate we cannot verify it.

=end original

ピアから証明書を取得します。
ピアが証明書を提示しない場合、我々はそれを確認できません。
(TBR)

=item *

=begin original

Check if we trust the certificate, e.g. make sure its not a forgery.

=end original

証明書が信頼できるかどうかを確認します。
たとえば、証明書が偽造でないことを確認します。
(TBR)

=begin original

We believe that a certificate is not a fake, if we either know the certificate
already or if we B<trust> the issuer (the CA) and can verify the issuers
signature on the certificate.
In reality there is often a hierarchy of certificate agencies and we only
directly trust the root of this hierarchy.
In this case the peer not only sends his own certificate, but also all
B<intermediate certificates>.
Verification will be done by building a B<trust path> from the trusted root up
to the peers certificate and checking in each step if the we can verify the
issuers signature.

=end original

証明書がすでにわかっている場合、または発行者(CA)をB<trust>し、証明書上の発行者の署名を確認できる場合、証明書は偽物ではないと信じます。
実際には、多くの場合、証明書機関の階層があり、この階層のルートのみを直接信頼します。
この場合、ピアは自身の証明書だけでなく、すべてのB<intermediate certificates>も送信します。
検証は、信頼できるルートからピア証明書までのB<trust path>を構築し、発行者の署名を確認できるかどうかを各ステップでチェックすることによって行われます。
(TBR)

=begin original

This step often causes problems, because the client does not know the necessary
trusted root certificates. These are usually stored in a system dependent
CA store, but often the browsers have their own CA store.

=end original

クライアントが必要な信頼できるルート証明書を認識していないため、この手順では問題が発生することがよくあります。
これらは通常、システムに依存するCAストアに保存されますが、多くの場合、ブラウザには独自のCAストアがあります。
(TBR)

=item *

=begin original

Check if the certificate is still valid.
Each certificate has a lifetime and should not be used after that time because
it might be compromised or the underlying cryptography got broken in the mean
time.

=end original

証明書がまだ有効であるかどうかを確認してください。
各証明書には有効期間があり、その期間が経過すると証明書が侵害されたり、基礎となる暗号化が破られたりする可能性があるため、その期間が経過した後は使用しないでください。
(TBR)

=item *

=begin original

Check if the subject of the certificate matches the peer.
This is like comparing the picture on the identity card against the person
representing the identity card.

=end original

証明書のサブジェクトがピアと一致するかどうかを確認します。
これは、IDカード上の画像をIDカードを表す人物と比較するようなものです。
(TBR)

=begin original

When connecting to a server this is usually done by comparing the hostname used
for connecting against the names represented in the certificate.
A certificate might contain multiple names or wildcards, so that it can be used
for multiple hosts (e.g.  *.example.com and *.example.org).

=end original

サーバに接続する場合、これは通常、接続に使用されるホスト名を証明書で表される名前と比較することによって行われます。
証明書には、複数のホスト(*.example.comや*.example.orgなど)に使用できるように、複数の名前またはワイルドカードを含めることができます。
(TBR)

=begin original

Although nobody sane would accept an identity card where the picture does not
match the person we see, it is a common implementation error with SSL to omit
this check or get it wrong.

=end original

写真が私たちが見ている人と一致しないIDカードを受け入れる人は誰もいませんが、このチェックを省略したり間違ったりするのは、SSLの一般的な実装エラーです。
(TBR)

=item *

=begin original

Check if the certificate was revoked by the issuer.
This might be the case if the certificate was compromised somehow and now
somebody else might use it to claim the wrong identity.
Such revocations happened a lot after the heartbleed attack.

=end original

証明書が発行者によって取り消されたかどうかを確認します。
これは、証明書が何らかの形で侵害され、他の誰かがそれを使用して間違ったIDを主張する可能性がある場合に当てはまります。
このような取り消しは、ハートブリード攻撃の後に多く発生しました。
(TBR)

=begin original

For SSL there are two ways to verify a revocation, CRL and OCSP.
With CRLs (Certificate Revocation List) the CA provides a list of serial numbers
for revoked certificates. The client somehow has to download the list
(which can be huge) and keep it up to date.
With OCSP (Online Certificate Status Protocol) the client can check a single
certificate directly by asking the issuer.

=end original

SSLで失効を検証するには、CRLとOCSPの2つの方法があります。
CRL(証明書失効リスト)を使用すると、CAは失効した証明書のシリアル番号のリストを提供します。
クライアントは何らかの方法でリスト(巨大になる場合があります)をダウンロードし、最新の状態に保つ必要があります。
OCSP(オンライン証明書ステータスプロトコル)を使用すると、クライアントは発行者に尋ねることで単一の証明書を直接チェックできます。
(TBR)

=begin original

Revocation is the hardest part of the verification and none of todays browsers
gets it fully correct. But they are still better than most other implementations
which don't implement revocation checks or leave the hard parts to the
developer.

=end original

失効は検証の中で最も困難な部分であり、今日のブラウザでは完全に正しいものはない。
しかし、失効チェックを実装していない、または困難な部分を開発者に任せていない他のほとんどの実装よりも優れている。
(TBR)

=back

=begin original

When accessing a web site with SSL or delivering mail a secure way the
identity is usually only checked one way, e.g. the client wants to make sure it
talks to the right server, but the server usually does not care which client it
is.
But, sometimes the server wants to identify the client too and will request a
certificate from the client which the server must verify in a similar way.

=end original

SSLを使用してWebサイトにアクセスしたり、安全な方法でメールを配信したりする場合、IDは通常1つの方法でしかチェックされない。
たとえば、クライアントは正しいサーバと通信していることを確認したいが、サーバは通常、どのクライアントであるかを気にしない。
しかし、サーバもクライアントを識別したい場合があり、サーバが同様の方法で検証する必要があるクライアントからの証明書を要求する。
(TBR)

=head1 Basic SSL Client

=begin original

A basic SSL client is simple:

=end original

基本的なSSLクライアントは単純です。
(TBR)

    my $client = IO::Socket::SSL->new('www.example.com:443')
	or die "error=$!, ssl_error=$SSL_ERROR";

=begin original

This will take the OpenSSL default CA store as the store for the trusted CA.
This usually works on UNIX systems.
If their are no certificates in the store it will try use L<Mozilla::CA> which
provides the default CAs of Firefox.

=end original

これは、OpenSSLのデフォルトCAストアを信頼できるCAのストアとして使用します。
これは通常、UNIXシステムで機能します。
ストアに証明書がない場合は、FirefoxのデフォルトCAを提供するL<Mozilla::CA>を使用しようとします。
(TBR)

=begin original

In the default settings IO::Socket::SSL will use a safer cipher set and SSL
version, do a proper hostname check against the certificate and uses SNI (server
name indication) to send the hostname inside the SSL handshake. This is
necessary to work with servers, which have different certificates behind the
same IP address.
It will also check the revocation of the certificate with OCSP, but currently
only if the server provides OCSP stapling (for deeper checks see
C<ocsp_resolver> method).

=end original

デフォルト設定では、IO::Socket::SSLはより安全な暗号セットとSSLバージョンを使用し、証明書に対して適切なホスト名チェックを行い、SNI(サーバー名表示)を使用してSSLハンドシェイク内でホスト名を送信します。
これは、同じIPアドレスの背後に異なる証明書を持つサーバーを操作するために必要です。
また、OCSPを使用して証明書の失効をチェックしますが、現在のところ、サーバーがOCSPステープルを提供している場合に限られます(より詳細なチェックについては、C<ocsp_resolver>メソッドを参照してください)。
(TBR)

=begin original

Lots of options can be used to change ciphers, SSL version, location of CA and
much more. See documentation of methods for details.

=end original

多くのオプションを使用して、暗号、SSLバージョン、CAの場所などを変更できます。
詳細については、メソッドの文書を参照してください。
(TBR)

=begin original

With protocols like SMTP it is necessary to upgrade an existing socket to SSL.
This can be done like this:

=end original

SMTPのようなプロトコルでは、既存のソケットをSSLにアップグレードする必要があります。
これは次のように行うことができます。
(TBR)

    my $client = IO::Socket::INET->new('mx.example.com:25') or die $!;
    # .. SMTP dialogs ... send STARTTLS and read reply ...
    # SSL upgrade
    IO::Socket::SSL->start_SSL($client,
	# explicitly set hostname we should use for SNI
	SSL_hostname => 'mx.example.com'
    ) or die $SSL_ERROR;

=begin original

A more complete example for a simple HTTP client:

=end original

単純なHTTPクライアントのより完全な例を示します。
(TBR)

    my $client = IO::Socket::SSL->new(
	# where to connect
	PeerHost => "www.example.com",
	PeerPort => "https",

	# certificate verification - VERIFY_PEER is default
	SSL_verify_mode => SSL_VERIFY_PEER,

	# location of CA store
	# need only be given if default store should not be used
	SSL_ca_path => '/etc/ssl/certs', # typical CA path on Linux
	SSL_ca_file => '/etc/ssl/cert.pem', # typical CA file on BSD

	# or just use default path on system:
	IO::Socket::SSL::default_ca(), # either explicitly
	# or implicitly by not giving SSL_ca_*

	# easy hostname verification
	# It will use PeerHost as default name a verification
	# scheme as default, which is safe enough for most purposes.
	SSL_verifycn_name => 'foo.bar',
	SSL_verifycn_scheme => 'http',

	# SNI support - defaults to PeerHost
	SSL_hostname => 'foo.bar',

    ) or die "failed connect or ssl handshake: $!,$SSL_ERROR";

    # send and receive over SSL connection
    print $client "GET / HTTP/1.0\r\n\r\n";
    print <$client>;

=begin original

And to do revocation checks with OCSP (only available with OpenSSL 1.0.0 or
higher and Net::SSLeay at least 1.59):

=end original

また、OCSP(OpenSSL 1.0.0以降およびNet::SSLeay 1.59以上でのみ利用可能)を使用して失効チェックを行うには、次の手順を実行します。
(TBR)

    # default will try OCSP stapling and check only leaf certificate
    my $client = IO::Socket::SSL->new($dst);

    # better yet: require checking of full chain
    my $client = IO::Socket::SSL->new(
	PeerAddr => $dst,
	SSL_ocsp_mode => SSL_OCSP_FULL_CHAIN,
    );

    # even better: make OCSP errors fatal
    # (this will probably fail with lots of sites because of bad OCSP setups)
    # also use common OCSP response cache
    my $ocsp_cache = IO::Socket::SSL::OCSP_Cache->new;
    my $client = IO::Socket::SSL->new(
	PeerAddr => $dst,
	SSL_ocsp_mode => SSL_OCSP_FULL_CHAIN|SSL_OCSP_FAIL_HARD,
	SSL_ocsp_cache => $ocsp_cache,
    );

    # disable OCSP stapling in case server has problems with it
    my $client = IO::Socket::SSL->new(
	PeerAddr => $dst,
	SSL_ocsp_mode => SSL_OCSP_NO_STAPLE,
    );

    # check any certificates which are not yet checked by OCSP stapling or
    # where we have already cached results. For your own resolving combine
    # $ocsp->requests with $ocsp->add_response(uri,response).
    my $ocsp = $client->ocsp_resolver();
    my $errors = $ocsp->resolve_blocking();
    if ($errors) {
	warn "OCSP verification failed: $errors";
	close($client);
    }

=head1 Basic SSL Server

=begin original

A basic SSL server looks similar to other L<IO::Socket> servers, only that it
also contains settings for certificate and key:

=end original

基本SSLサーバーは、他のL<IO::Socket>サーバーと似ていますが、証明書とキーの設定も含まれている点が異なります。
(TBR)

    # simple server
    my $server = IO::Socket::SSL->new(
	# where to listen
	LocalAddr => '127.0.0.1',
	LocalPort => 8080,
	Listen => 10,

	# which certificate to offer
	# with SNI support there can be different certificates per hostname
	SSL_cert_file => 'cert.pem',
	SSL_key_file => 'key.pem',
    ) or die "failed to listen: $!";

    # accept client
    my $client = $server->accept or die
	"failed to accept or ssl handshake: $!,$SSL_ERROR";

=begin original

This will automatically use a secure set of ciphers and SSL version and also
supports Forward Secrecy with (Elliptic-Curve) Diffie-Hellmann Key Exchange.

=end original

これにより、安全な暗号セットとSSLバージョンが自動的に使用され、(楕円曲線)ディフィーヘルマン鍵交換による前方秘匿性もサポートされる。
(TBR)

=begin original

If you do a forking a threading server it is recommended to do the SSL handshake
inside the new process/thread, so that the master is free for new connections.
Because a client with improper or slow SSL handshake could make the server
block in the handshake which would be bad to do on the listening socket:

=end original

スレッド化サーバーをフォークする場合は、新しいプロセス/スレッド内でSSLハンドシェイクを行うことをお勧めします。
これにより、マスターは新しい接続に対して自由になります。
SSLハンドシェイクが不適切または遅いクライアントは、ハンドシェイクでサーバーをブロックする可能性があり、これはリスニングソケットで行うのが悪いためです。
(TBR)

    # inet server
    my $server = IO::Socket::INET->new(
	# where to listen
	LocalAddr => '127.0.0.1',
	LocalPort => 8080,
	Listen => 10,
    );

    # accept client
    my $client = $server->accept or die;

    # SSL upgrade client (in new process/thread)
    IO::Socket::SSL->start_SSL($client,
	SSL_server => 1,
	SSL_cert_file => 'cert.pem',
	SSL_key_file => 'key.pem',
    ) or die "failed to ssl handshake: $SSL_ERROR";

=begin original

Like with normal sockets neither forking nor threading servers scale well.
It is recommended to use non-blocking sockets instead, see
L</"Using Non-Blocking Sockets">

=end original

通常のソケットと同様に、サーバのフォークもスレッド化もうまくスケーリングできません。
代わりに非ブロッキングソケットを使用することをお勧めします。
L</"非ブロッキングソケットの使用">を参照してください。
(TBR)

=head1 Common Usage Errors

=begin original

This is a list of typical errors seen with the use of IO::Socket::SSL:

=end original

これは、IO::Socket::SSLの使用時に発生する一般的なエラーのリストです。
(TBR)

=over 4

=item *

=begin original

Disabling verification with C<SSL_verify_mode>.

=end original

C<SSL_verify_mode>による検証を無効にします。
(TBR)

=begin original

As described in L</"Essential Information About SSL/TLS"> a proper
identification of the peer is essential and failing to verify makes
Man-In-The-Middle attacks possible.

=end original

L</"Essential Information About SSL/TLS">で説明されているように、ピアの適切な識別は不可欠であり、検証に失敗すると中間者攻撃が可能になります。
(TBR)

=begin original

Nevertheless, lots of scripts and even public modules or applications disable
verification, because it is probably the easiest way to make the thing working
and usually nobody notices any security problems anyway.

=end original

それにもかかわらず、多くのスクリプトや公開されたモジュールやアプリケーションでさえ、検証を無効にしています。
なぜなら、検証はおそらく最も簡単に動作させる方法であり、通常は誰もセキュリティ上の問題に気づかないからです。
(TBR)

=begin original

If the verification does not succeed with the default settings one can do the
following:

=end original

既定の設定で検証に失敗した場合は、次の操作を実行できます。
(TBR)

=over 8

=item *

=begin original

Make sure the needed CAs are in the store, maybe use C<SSL_ca_file> or
C<SSL_ca_path> to specify a different CA store.

=end original

必要なCAがストア内にあることを確認します。
C<SSL_ca_file>またはC<SSL_ca_path>を使用して別のCAストアを指定します。
(TBR)

=item *

=begin original

If the validation fails because the certificate is self-signed and that's what
you expect, you can use the C<SSL_fingerprint> option to accept specific
certificates by their certificate fingerprint.

=end original

証明書が自己署名されているために検証が失敗した場合は、C<SSL_fingerprint>オプションを使用して、証明書フィンガープリントによって特定の証明書を受け入れることができます。
(TBR)

=item *

=begin original

If the validation failed because the hostname does not match and you cannot
access the host with the name given in the certificate, you can use
C<SSL_verifycn_name> to specify they hostname you expect in the certificate.

=end original

ホスト名が一致せず、証明書で指定された名前のホストにアクセスできないために検証が失敗した場合は、C<SSL_verifycn_name>を使用して、証明書で必要なホスト名を指定できます。
(TBR)

=back

=begin original

A common error pattern is also to disable verification if they found no CA
store (different modules look at different "default" places).
Because IO::Socket::SSL is now able to provide a usable CA store on most
platforms (UNIX, Mac OSX and Windows) it is better to use the defaults provided
by IO::Socket::SSL.
If necessary these can be checked with the C<default_ca> method.

=end original

一般的なエラーパターンは、CAストアが見つからない場合に検証を無効にすることです(異なるモジュールは異なる「デフォルト」の場所を参照します)。
IO::Socket::SSLは、ほとんどのプラットフォーム(UNIX、Mac OSX、およびWindows)で使用可能なCAストアを提供できるようになったため、IO::Socket::SSLによって提供されるデフォルトを使用することをお勧めします。
必要に応じて、これらはC<default_ca>メソッドでチェックできます。
(TBR)

=item *

=begin original

Polling of SSL sockets (e.g. select, poll and other event loops).

=end original

SSLソケットのポーリング(選択、ポーリング、その他のイベントループなど)。
(TBR)

=begin original

If you sysread one byte on a normal socket it will result in a syscall to read
one byte. Thus, if more than one byte is available on the socket it will be kept
in the network stack of your OS and the next select or poll call will return the
socket as readable.
But, with SSL you don't deliver single bytes. Multiple data bytes are packet
and encrypted together in an SSL frame. Decryption can only be done on the whole
frame, so a sysread for one byte actually reads the complete SSL frame from the
socket, decrypts it and returns the first decrypted byte. Further sysreads will
return more bytes from the same frame until all bytes are returned and the
next SSL frame will be read from the socket.

=end original

通常のソケットで1バイトをsysreadすると、1バイトを読み取るためのsyscallが発生します。
したがって、ソケットで1バイト以上が使用可能な場合は、OSのネットワークスタックに保持され、次のselectまたはpoll呼び出しでソケットが読み取り可能として返されます。
しかし、SSLでは、単一バイトを配信することはできません。
複数のデータバイトがパケット化され、SSLフレーム内で一緒に暗号化されます。
復号化はフレーム全体に対してのみ実行できるため、1バイトのsysreadは実際にソケットから完全なSSLフレームを読み取り、それを復号化して最初の復号化されたバイトを返します。
さらにsysreadを実行すると、すべてのバイトが返されて次のSSLフレームがソケットから読み取られるまで、同じフレームからさらに多くのバイトが返されます。
(TBR)

=begin original

Thus, in order to decide if you can read more data (e.g. if sysread will block)
you must check if there are still data in the current SSL frame by calling
C<pending> and if there are no data pending you might check the underlying
socket with select or poll.
Another way might be if you try to sysread at least 16kByte all the time.
16kByte is the maximum size of an SSL frame and because sysread returns data
from only a single SSL frame you guarantee this way, that there are no pending
data.

=end original

したがって、より多くのデータを読み取ることができるかどうか(たとえば、sysreadがブロックするかどうか)を判断するには、C<pending>を呼び出して現在のSSLフレームにまだデータがあるかどうかを確認する必要があります。
保留中のデータがない場合は、selectまたはpollを使用して基礎となるソケットを確認します。
別の方法としては、常に16 kByte以上のsysreadを試みることです。
16 kByteはSSLフレームの最大サイズです。
sysreadは1つのSSLフレームからのみデータを返すため、保留中のデータがないことを保証します。
(TBR)

=begin original

See also L</"Using Non-Blocking Sockets">.

=end original

L</"Using Non-Blocking Sockets">も参照してください。
(TBR)

=item *

=begin original

Set 'SSL_version' or 'SSL_cipher_list' to a "better" value.

=end original

'SSL_version'または'SSL_cipher_list'を"より適切な"値に設定してください。
(TBR)

=begin original

IO::Socket::SSL tries to set these values to reasonable secure values, which
are compatible with the rest of the world.
But, there are some scripts or modules out there, which tried to be smart and
get more secure or compatible settings.
Unfortunatly, they did this years ago and never updated these values, so they
are still forced to do only 'TLSv1' (instead of also using TLSv12 or TLSv11).
Or they set 'HIGH' as the cipher list and thought they are secure, but did not
notice that 'HIGH' includes anonymous ciphers, e.g. without identification of
the peer.

=end original

IO::Socket::SSLは、これらの値を、世界の他の地域と互換性のある妥当な安全な値に設定しようとします。
しかし、スマートにして、より安全で互換性のある設定を取得しようとしたスクリプトやモジュールがいくつかあります。
残念なことに、彼らは何年も前にこれを行い、これらの値を更新しなかったので、彼らは依然として「TLSv1」のみを行うことを余儀なくされています(TLSv12またはTLSv11も使用する代わりに)。
または、彼らは暗号リストとして「HIGH」を設定し、安全だと思っていましたが、「HIGH」に匿名の暗号が含まれていることに気づきませんでした(例えば、ピアの識別なし)。
(TBR)

=begin original

So it is recommended to leave the settings at the secure defaults which
IO::Socket::SSL sets and which get updated from time to time to
better fit the real world.

=end original

したがって、IO::Socket::SSLが設定し、現実世界により適合するように時々更新される安全なデフォルトの設定のままにしておくことをお勧めします。
(TBR)

=item *

=begin original

Make SSL settings inacessible by the user, together with bad builtin settings.

=end original

誤った組み込み設定とともに、ユーザーがSSL設定にアクセスできないようにします。
(TBR)

=begin original

Some modules use IO::Socket::SSL, but don't make the SSL settings available
to the user. This is often combined with bad builtin settings or defaults (like
switching verification off).

=end original

一部のモジュールはIO::Socket::SSLを使用しますが、SSL設定をユーザーが利用できるようにしません。
これは、多くの場合、組み込みの設定やデフォルト(検証をオフにするなど)と組み合わされます。
(TBR)

=begin original

Thus the user needs to hack around these restrictions by using
C<set_args_filter_hack> or similar.

=end original

したがって、ユーザはC<set_args_filter_hack>などを使用して、これらの制限を回避する必要があります。
(TBR)

=item *

=begin original

Use of constants as strings.

=end original

定数を文字列として使用する。
(TBR)

=begin original

Constants like C<SSL_VERIFY_PEER> or C<SSL_WANT_READ> should be used as
constants and not be put inside quotes, because they represent numerical values.

=end original

C<SSL_VERIFY_PEER>やC<SSL_WANT_READ>などの定数は、数値を表すため、定数として使用し、引用符で囲まないでください。
(TBR)

=back

=head1 Common Problems with SSL

=begin original

SSL is a complex protocol with multiple implementations and each of these has
their own quirks. While most of these implementations work together it often
gets problems with older versions, minimal versions in load balancers or plain
wrong setups.

=end original

SSLは複数の実装を持つ複雑なプロトコルであり、それぞれに独自の癖があります。
これらの実装のほとんどは連携して動作しますが、古いバージョン、ロードバランサの最小バージョン、または単純な間違った設定で問題が発生することがよくあります。
(TBR)

=begin original

Unfortunatly these problems are hard to debug.
Helpful for debugging are a knowledge of SSL internals, wireshark and the use of
the debug settings of IO::Socket::SSL and L<Net::SSLeay>, which can both be
set with C<$IO::Socket::SSL::DEBUG>.
The following debugs levels are defined, but used not in a consistent way:

=end original

残念ながら、これらの問題をデバッグするのは困難です。
デバッグに役立つのは、SSL内部、wireshark、およびC<$IO::Socket::SSL::DEBUG>で設定できるIO::Socket::SSLとL<Net::SSLeay>のデバッグ設定の使用に関する知識です。
次のデバッグレベルが定義されていますが、一貫した方法で使用されていません。
(TBR)

=over 4

=item *

=begin original

0 - No debugging (default).

=end original

0 - デバッグなし(デフォルト)

=item *

=begin original

1 - Print out errors from IO::Socket::SSL and ciphers from Net::SSLeay.

=end original

1 - IO::Socket::SSL からのエラーと Net::SSLeay からの暗号を出力。

=item *

=begin original

2 - Print also information about call flow from IO::Socket::SSL and progress
information from Net::SSLeay.

=end original

2 - IO::Socket::SSL からの呼び出しフローと Net::SSLeay からの進捗情報も出力。

=item *

=begin original

3 - Print also some data dumps from IO::Socket::SSL and from Net::SSLeay.

=end original

3 - IO::Socket::SSL からと Net::SSLeay からの一部のデータダンプも出力。

=back

=begin original

Also, C<util/analyze-ssl.pl> in the distribution might be a helpful tool when
debugging SSL problems, as do the C<openssl> command line tool and a check with
a different SSL implementation (e.g. a web browser).

=end original

また、ディストリビューションのC<util/analyze-ssl.pl>は、C<openssl>コマンドラインツールや別のSSL実装(例えば、ウェブブラウザ)でのチェックと同様に、SSL問題をデバッグするときに役立つツールである可能性があります。
(TBR)

=begin original

The following problems are not uncommon:

=end original

次のような問題はまれではありません。
(TBR)

=over 4

=item *

=begin original

Bad server setup: missing imtermediate certificates.

=end original

不正なサーバ設定:中間証明書がありません。
(TBR)

=begin original

It is a regular problem that administrators fail to include all necessary
certificates into their server setup, e.g. everything needed to build the trust
chain from the trusted root.
If they check the setup with the browser everything looks ok, because browsers
work around these problems by caching any intermediate certificates and apply
them to new connections if there are certificates missing.

=end original

信頼されたルートから信頼チェーンを構築するために必要なすべてのものなど、管理者が必要なすべての証明書をサーバ設定に含めることができないことは、よくある問題です。
ブラウザで設定を確認すると、すべてが正常に見えます。
これは、ブラウザが中間証明書をキャッシュすることによってこれらの問題を回避し、証明書が欠落している場合にはそれらを新しい接続に適用するためです。
(TBR)

=begin original

But, fresh browser profiles which never have seen these intermediates cannot
fill in the missing certificates and fail to verify, and the same is with
IO::Socket::SSL.

=end original

しかし、これらの中間物を見たことのない新しいブラウザプロファイルは、欠落した証明書を埋めることができず、検証に失敗します。
IO::Socket::SSLも同様です。
(TBR)

=item *

=begin original

Old version of server or load balancer, which do not understand specific TLS
versions or croak on specific data.

=end original

サーバーまたはロードバランサーの古いバージョン。
特定のTLSバージョンを認識しないか、特定のデータを破壊します。
(TBR)

=begin original

From time to time one encounters an SSL peer, which just closes the connection
inside the SSL handshake. This can usually be workarounded by downgrading the
SSL version, e.g. by setting C<SSL_version>. Modern Browsers usually deal with
such servers by automatically downgrading the SSL version and repeat the
connection attempt until they succeed.

=end original

時々、SSLハンドシェイク内の接続を閉じるだけのSSLピアに遭遇することがあります。
これは通常、C<SSL_version>を設定するなどしてSSLバージョンをダウングレードすることで回避できます。
最新のブラウザは通常、SSLバージョンを自動的にダウングレードすることでそのようなサーバを処理し、成功するまで接続試行を繰り返します。
(TBR)

=begin original

Worse servers do not close the underlying TCP connection but instead just
drop the relevant packet. This is harder to detect because it looks like a
stalled connection. But downgrading the SSL version often works here too.

=end original

悪いサーバは、基礎となるTCP接続を閉じず、代わりに関連するパケットをドロップします。
これは、停止した接続のように見えるため、検出が困難です。
しかし、SSLバージョンのダウングレードは、ここでも機能することがよくあります。
(TBR)

=begin original

A cause of such problems are often load balancers or security devices, which
have hardware acceleration and only a minimal (and less robust) SSL stack. They
can often be detected because they support much fewer ciphers than other
implementations.

=end original

このような問題の原因は、多くの場合、ハードウェアアクセラレーションと最小限の(堅牢ではない)SSLスタックしかないロードバランサまたはセキュリティデバイスです。
これらは、他の実装よりもはるかに少ない暗号しかサポートしていないため、検出されることがよくあります。
(TBR)

=item *

=begin original

Bad or old OpenSSL versions.

=end original

OpenSSLのバージョンが不良か古い。
(TBR)

=begin original

IO::Socket::SSL uses OpenSSL with the help of the L<Net::SSLeay> library. It
is recommend to have a recent version of this library, because it has more
features and usually fewer known bugs.

=end original

IO::Socket::SSLは、L<Net::SSLeay>ライブラリの助けを借りてOpenSSLを使用します。
より多くの機能があり、通常は既知のバグが少ないため、このライブラリの最新バージョンを使用することをお勧めします。
(TBR)

=back

=head1 Using Non-Blocking Sockets

=begin original

If you have a non-blocking socket, the expected behavior on read, write, accept
or connect is to set C<$!> to EAGAIN if the operation can not be completed
immediately.

=end original

非ブロッキングソケットを使用している場合、読み取り、書き込み、受け入れ、または接続時の予期される動作は、操作がすぐに完了できない場合にC<$!>をEAGAINに設定することです。
(TBR)

=begin original

With SSL handshakes might occure at any time, even within an established
connections. In this cases it is necessary to finish the handshake before
you can read or write data. This might result in situations where you want to
read but must first finish the write of a handshake or where you want to write
but must first finish a read.
In these cases C<$!> is set to EGAIN like expected, and additionally
C<$SSL_ERROR> is set to either SSL_WANT_READ or SSL_WANT_WRITE.
Thus if you get EAGAIN on a SSL socket you must check C<$SSL_ERROR> for
SSL_WANT_* and adapt your event mask accordingly.

=end original

SSLを使用すると、確立された接続内であっても、いつでもハンドシェイクが発生する可能性があります。
この場合、データの読取りまたは書込みを行う前にハンドシェイクを終了する必要があります。
これにより、読取りが必要でも最初にハンドシェイクの書込みを終了する必要がある場合や、書込みが必要でも最初に読取りを終了する必要がある場合があります。
このような場合、C<$!>は予想どおりEGAINに設定され、さらにC<$SSL_ERROR>はSSL_WANT_READまたはSSL_WANT_WRITEのいずれかに設定されます。
したがって、SSLソケットでEAGAINを取得する場合は、C<$SSL_ERROR>でSSL_WANT_*をチェックし、それに応じてイベントマスクを調整する必要があります。
(TBR)

=begin original

Using readline on non-blocking sockets does not make much sense and I would
advise against using it.
And, while the behavior is not documented for other L<IO::Socket> classes, it
will try to emulate the behavior seen there, e.g. to return the received data
instead of blocking, even if the line is not complete. If an unrecoverable error
occurs it will return nothing, even if it already received some data.

=end original

非ブロッキングソケットでreadlineを使用するのはあまり意味がないので、使用しないことをお勧めします。
また、この動作は他のL<IO::Socket>クラスでは文書化されていませんが、そこで見られる動作をエミュレートしようとします。
たとえば、行が完全でなくても、ブロックする代わりに受信したデータを返します。
回復不能なエラーが発生した場合、すでにデータを受信していても何も返されません。
(TBR)

=begin original

Also, I would advise against using C<accept> with a non-blocking SSL object,
because it might block and this is not what most would expect. The reason for
this is that accept on a non-blocking TCP socket (e.g. IO::Socket::IP,
IO::Socket::INET..) results in a new TCP socket, which does not inherit the
non-blocking behavior of the master socket. And thus the initial SSL handshake
on the new socket inside C<IO::Socket::SSL::accept> will be done in a blocking
way. To work around this you are safer in doing a TCP accept and later upgrade the
TCP socket in a non-blocking way with C<start_SSL> and C<accept_SSL>.

=end original

また、非ブロッキングSSLオブジェクトでC<accept>を使用しないことをお勧めします。
これは、ブロックされる可能性があり、これはほとんどの人が予想するものではないためです。
その理由は、非ブロッキングTCPソケット(IO::Socket::IP、IO::Socket::INETなど)でのacceptは、マスターソケットの非ブロッキング動作を継承しない新しいTCPソケットになるためです。
したがって、C<IO::Socket::SSL::accept>内の新しいソケットでの最初のSSLハンドシェイクは、ブロッキング方式で行われます。
この問題を回避するには、TCP acceptを実行し、後でC<start_SSL>とC<accept_SSL>を使用して非ブロッキング方式でTCPソケットをアップグレードする方が安全です。
(TBR)

    my $cl = IO::Socket::SSL->new($dst);
    $cl->blocking(0);
    my $sel = IO::Select->new($cl);
    while (1) {
	# with SSL a call for reading n bytes does not result in reading of n
	# bytes from the socket, but instead it must read at least one full SSL
	# frame. If the socket has no new bytes, but there are unprocessed data
	# from the SSL frame can_read will block!

	# wait for data on socket
	$sel->can_read();

	# new data on socket or eof
	READ:
	# this does not read only 1 byte from socket, but reads the complete SSL
	# frame and then just returns one byte. On subsequent calls it than
	# returns more byte of the same SSL frame until it needs to read the
	# next frame.
	my $n = sysread( $cl,my $buf,1);
	if ( ! defined $n ) {
	    die $! if not ${EAGAIN};
	    next if $SSL_ERROR == SSL_WANT_READ;
	    if ( $SSL_ERROR == SSL_WANT_WRITE ) {
		# need to write data on renegotiation
		$sel->can_write;
		next;
	    }
	    die "something went wrong: $SSL_ERROR";
	} elsif ( ! $n ) {
	    last; # eof
	} else {
	    # read next bytes
	    # we might have still data within the current SSL frame
	    # thus first process these data instead of waiting on the underlying
	    # socket object
	    goto READ if $self->pending;  # goto sysread
	    next;                         # goto $sel->can_read
	}
    }

=head1 Advanced Usage

=head2 SNI Support

=begin original

Newer extensions to SSL can distinguish between multiple hostnames on the same
IP address using Server Name Indication (SNI).

=end original

SSLの新しい拡張機能では、サーバー名表示(SNI)を使用して、同じIPアドレス上の複数のホスト名を区別できます。
(TBR)

=begin original

Support for SNI on the client side was added somewhere in the OpenSSL 0.9.8
series, but only with 1.0 a bug was fixed when the server could not decide about
its hostname. Therefore client side SNI is only supported with OpenSSL 1.0 or
higher in IO::Socket::SSL.
With a supported version, SNI is used automatically on the client side, if it
can determine the hostname from C<PeerAddr> or C<PeerHost> (which are synonyms
in the underlying IO::Socket:: classes and thus should never be set both or at
least not to different values).
On unsupported OpenSSL versions it will silently not use SNI.
The hostname can also be given explicitly given with C<SSL_hostname>, but in
this case it will throw in error, if SNI is not supported.
To check for support you might call C<IO::Socket::SSL->can_client_sni()>.

=end original

クライアント側でのSNIのサポートは、OpenSSL 0.9.8シリーズのどこかで追加されましたが、1.0でのみ、サーバがホスト名を決定できないときにバグが修正されました。
そのため、クライアント側のSNIは、IO::Socket::SSLのOpenSSL 1.0以降でのみサポートされています。
サポートされているバージョンでは、C<PeerAddr>またはC<PeerHost>(基礎となるIO::Socket::クラスの同義語であるため、両方に設定したり、少なくとも異なる値に設定したりしないでください)からホスト名を決定できる場合、SNIはクライアント側で自動的に使用されます。
サポートされていないOpenSSLバージョンでは、SNIはサイレントに使用されません。
ホスト名はC<SSL_hostname>で明示的に指定することもできますが、この場合、SNIがサポートされていないとエラーが発生します。
サポートを確認するには、C<IO::Socket::SSL->can_client_sni()>を呼び出します。
(TBR)

=begin original

On the server side earlier versions of OpenSSL are supported, but only together
with L<Net::SSLeay> version >= 1.50.
To check for support you might call C<IO::Socket::SSL->can_server_sni()>.
If server side SNI is supported, you might specify different certificates per
host with C<SSL_cert*> and C<SSL_key*>, and check the requested name using
C<get_servername>.

=end original

サーバ側では、以前のバージョンのOpenSSLがサポートされていますが、L<Net::SSLeay>version>=1.50との組み合わせのみです。
サポートを確認するには、C<IO::Socket::SSL->can_server_sni()>を呼び出します。
サーバ側のSNIがサポートされている場合は、C<SSL_cert*>とC<SSL_key*>でホストごとに異なる証明書を指定し、C<get_servername>を使用して要求された名前を確認します。
(TBR)

=head2 Talk Plain and SSL With The Same Socket

=begin original

It is often required to first exchange some plain data and then upgrade the
socket to SSL after some kind of STARTTLS command. Protocols like FTPS even
need a way to downgrade the socket again back to plain.

=end original

多くの場合、最初にプレーンなデータを交換し、何らかのSTARTTLSコマンドの後にソケットをSSLにアップグレードする必要があります。
FTPSのようなプロトコルでは、ソケットを再びプレーンにダウングレードする方法さえ必要です。
(TBR)

=begin original

The common way to do this would be to create a normal socket and use start_SSL
to upgrade and stop_SSL to downgrade:

=end original

これを行う一般的な方法は、通常のソケットを作成し、start_SSLを使用してアップグレードし、stop_SSLを使用してダウングレードすることです。
(TBR)

    my $sock = IO::Socket::INET->new(...) or die $!;
    ... exchange plain data on $sock until starttls command ...
    IO::Socket::SSL->start_SSL($sock,%sslargs) or die $SSL_ERROR;
    ... now $sock is a IO::Socket::SSL object ...
    ... exchange data with SSL on $sock until stoptls command ...
    $sock->stop_SSL or die $SSL_ERROR;
    ... now $sock is again a IO::Socket::INET object ...

=begin original

But, lots of modules just derive directly from IO::Socket::INET.
While this base class can be replaced with IO::Socket::SSL these modules cannot
easily support different base classes for SSL and plain data and switch between
these classes on a starttls command.

=end original

しかし、多くのモジュールはIO::Socket::INETから直接派生しているだけです。
この基本クラスはIO::Socket::SSLに置き換えることができますが、これらのモジュールはSSLとプレーンデータの異なる基本クラスを簡単にサポートできず、starttlsコマンドでこれらのクラスを切り替えることができません。
(TBR)

=begin original

To help in this case, IO::Socket::SSL can be reduced to a plain socket on
startup, and connect_SSL/accept_SSL/start_SSL can be used to enable SSL and
stop_SSL to talk plain again:

=end original

この場合、IO::Socket::SSLを起動時に単純なソケットに縮小し、connect_SSL/accept_SSL/start_SSLを使用してSSLを有効にし、stop_SSLを使用して再び単純に通信することができます。
(TBR)

    my $sock = IO::Socket::SSL->new(
	PeerAddr => ...
	SSL_startHandshake => 0,
	%sslargs
    ) or die $!;
    ... exchange plain data on $sock until starttls command ...
    $sock->connect_SSL or die $SSL_ERROR;
    ... now $sock is a IO::Socket::SSL object ...
    ... exchange data with SSL on $sock until stoptls command ...
    $sock->stop_SSL or die $SSL_ERROR;
    ... $sock is still a IO::Socket::SSL object ...
    ... but data exchanged again in plain ...

=head1 Integration Into Own Modules

=begin original

IO::Socket::SSL behaves similar to other L<IO::Socket> modules and thus could
be integrated in the same way, but you have to take special care when using
non-blocking I/O (like for handling timeouts) or using select or poll.
Please study the documentation on how to deal with these differences.

=end original

IO::Socket::SSLは他のL<IO::Socket>モジュールと同様に動作するため、同じ方法で統合できますが、非ブロッキングI/O(タイムアウトの処理など)を使用する場合や、選択またはポーリングを使用する場合は、特別な注意が必要です。
これらの違いに対処する方法については、文書を参照してください。
(TBR)

=begin original

Also, it is recommended to not set or touch most of the C<SSL_*> options, so
that they keep there secure defaults. It is also recommended to let the user
override this SSL specific settings without the need of global settings or hacks
like C<set_args_filter_hack>.

=end original

また、C<SSL_*>オプションのほとんどを設定または操作しないことをお勧めします。
これにより、安全なデフォルトが維持されます。
また、C<set_args_filter_hack>のようなグローバル設定やハックを必要とせずに、ユーザーがこのSSL固有の設定を上書きできるようにすることもお勧めします。
(TBR)

=begin original

The notable exception is C<SSL_verifycn_scheme>.
This should be set to the hostname verification scheme required by the module or
protocol.

=end original

注目すべき例外はC<SSL_verifycn_scheme>です。
これは、モジュールまたはプロトコルによって要求されるホスト名検証スキームに設定される必要があります。
(TBR)

=head1 Description Of Methods

(メソッドの説明)

=begin original

IO::Socket::SSL inherits from another IO::Socket module.
The choice of the super class depends on the installed modules:

=end original

IO::Socket::SSLは別のIO::Socketモジュールから継承します。
スーパークラスの選択は、インストールされているモジュールによって異なります。
(TBR)

=over 4

=item *

=begin original

If IO::Socket::IP with at least version 0.20 is installed it will use this
module as super class, transparently providing IPv6 and IPv4 support.

=end original

バージョン0.20以上のIO::Socket::IPがインストールされている場合は、このモジュールをスーパークラスとして使用し、IPv6とIPv4のサポートを透過的に提供します。
(TBR)

=item *

=begin original

If IO::Socket::INET6 is installed it will use this module as super class,
transparently providing IPv6 and IPv4 support.

=end original

IO::Socket::INET6がインストールされている場合は、このモジュールをスーパークラスとして使用し、IPv6とIPv4のサポートを透過的に提供します。
(TBR)

=item *

=begin original

Otherwise it will fall back to IO::Socket::INET, which is a perl core module.
With IO::Socket::INET you only get IPv4 support.

=end original

それ以外の場合は、perlコアモジュールであるIO::Socket::INETに戻ります。
IO::Socket::INETでは、IPv4のみがサポートされます。
(TBR)

=back

=begin original

Please be aware, that with the IPv6 capable super classes, it will lookup first
for the IPv6 address of a given hostname. If the resolver provides an IPv6
address, but the host cannot be reached by IPv6, there will be no automatic
fallback to IPv4.
To avoid these problems you can either force IPv4 by specifying and AF_INET
as C<Domain> of the socket or globally enforce IPv4 by loading IO::Socket::SSL
with the option 'inet4'.

=end original

IPv6 対応のスーパークラスでは、指定されたホスト名の IPv6 アドレスを
最初に探すことに注意してください。
リゾルバが IPv6 アドレスを提供するけれどもホストが IPv6 で到達できない場合、
自動的に IPv4 にフォールバックすることはしません。
これらの問題を回避するには、ソケットの C<ドメイン> として AF_INET を指定して
IPv4 を強制するか、オプション 'inet4' で IO::Socket::SSL をロードすることで
グローバルに IPv4 を強制します。

=begin original

IO::Socket::SSL will provide all of the methods of its super class, but
sometimes it will override them to match the behavior expected from SSL or to
provide additional arguments.

=end original

IO::Socket::SSLは、そのスーパークラスのすべてのメソッドを提供しますが、SSLから期待される動作に合わせたり、追加の引数を提供したりするために、それらをオーバーライドすることもあります。
(TBR)

=begin original

The new or changed methods are described below, but please read also the
section about SSL specific error handling.

=end original

新しいメソッドまたは変更されたメソッドについては以下で説明しますが、SSL固有のエラー処理に関するセクションもお読みください。
(TBR)

=over 4

=item Error Handling

=begin original

If an SSL specific error occurs the global variable C<$SSL_ERROR> will be set.
If the error occurred on an existing SSL socket the method C<errstr> will
give access to the latest socket specific error.
Both C<$SSL_ERROR> and C<errstr> method give a dualvar similar to C<$!>, e.g.
providing an error number in numeric context or an error description in string
context.

=end original

SSL固有のエラーが発生した場合、グローバル変数C<$SSL_ERROR>が設定されます。
エラーが既存のSSLソケットで発生した場合、メソッドC<errstr>は最新のソケット固有のエラーへのアクセスを提供します。
C<$SSL_ERROR>とC<errstr>の両方のメソッドは、C<$!>に似たデュアル変数を提供します。
たとえば、数値コンテキストでエラー番号を提供したり、文字列コンテキストでエラーの説明を提供したりします。
(TBR)

=item B<new(...)>

=begin original

Creates a new IO::Socket::SSL object.  You may use all the friendly options
that came bundled with the super class (e.g. IO::Socket::IP,
IO::Socket::INET, ...) plus (optionally) the ones described below.
If you don't specify any SSL related options it will do it's best in using
secure defaults, e.g. chosing good ciphers, enabling proper verification etc.

=end original

新しい IO::Socket::SSL オブジェクトを作成します。
(オプションで)以下のものも含めて、スーパークラス
(IO::Socket::IP, IO::Socket::INET など) についてくる
親切なオプションの全てを使うことが出来ます:
SSL 関連のオプションを何も指定しない場合、
セキュアなデフォルトを使うことで最善を尽くします;
つまり、良い暗号を選ぶ、適切な検証を有効にする、など。

=over 2

=item SSL_server

=begin original

Set this option to a true value, if the socket should be used as a server.
If this is not explicitly set it is assumed, if the Listen parameter is given
when creating the socket.

=end original

ソケットがサーバとして使われる場合にこのオプションに真を設定します。
これが明示的に設定されると、ソケットを作成するときに
Listen 引数が与えられることを仮定します。

=item SSL_hostname

=begin original

This can be given to specify the hostname used for SNI, which is needed if you
have multiple SSL hostnames on the same IP address. If not given it will try to
determine hostname from PeerAddr, which will fail if only IP was given or if
this argument is used within start_SSL.

=end original

これは、SNI に使用されるホスト名を指定するために指定できます;
これは、同じ IP アドレスに複数の SSL ホスト名がある場合に必要です。
指定されていない場合は、PeerAddr からホスト名を決定しようとします;
IP のみが指定されている場合、またはこの引数が start_SSL 内で
使用されている場合は失敗します。

=begin original

If you want to disable SNI set this argument to ''.

=end original

SNI を無効にする場合は、この引数を '' に設定します。

=begin original

Currently only supported for the client side and will be ignored for the server
side.

=end original

現在はクライアント側でのみサポートされており、サーバ側では無視されます。

=begin original

See section "SNI Support" for details of SNI the support.

=end original

SNIのサポートの詳細については、「SNIサポート」セクションを参照してください。
(TBR)

=item SSL_startHandshake

=begin original

If this option is set to false (defaults to true) it will no start the SSL
handshake yet. This has to be done later with C<accept_SSL> or C<connect_SSL>.
Before the handshake is started read/write etc can be used to exchange plain
data.

=end original

このオプションがfalse(デフォルトはtrue)に設定されている場合、SSLハンドシェイクはまだ開始されません。
これは、後でC<accept_SSL>またはC<connect_SSL>を使用して行う必要があります。
ハンドシェイクが開始される前に、読み取り/書き込みなどを使用してプレーンデータを交換できます。
(TBR)

=item SSL_ca | SSL_ca_file | SSL_ca_path

=begin original

Usually you want to verify that the peer certificate has been signed by a
trusted certificate authority. In this case you should use this option to
specify the file (C<SSL_ca_file>) or directory (C<SSL_ca_path>) containing the
certificateZ<>(s) of the trusted certificate authorities.
Also you can give X509* certificate handles (from L<Net::SSLeay> or
L<IO::Socket::SSL::Utils>) as a list with C<SSL_ca>. These will be added to the
CA store before path and file and thus take precedence.
If neither SSL_ca, nor SSL_ca_file or SSL_ca_path are set it will use
C<default_ca()> to determine the user-set or system defaults.
If you really don't want to set a CA set SSL_ca_file or SSL_ca_path to
C<\undef> or SSL_ca to an empty list. (unfortunatly C<''> is used by some
modules using IO::Socket::SSL when CA is not exlicitly given).

=end original

普通は相手の証明書が信頼できる認証局(certificate authority)によって
署名されたかを確認したいでしょう。
その場合信頼できる認証局の証明書が入っているファイル (C<SSL_ca_file>)
またはディレクトリ (C<SSL_ca_path>) の場所を示すため、このオプションを
使わなければなりません。
本当に SSL_ca_file を使わないのなら、undef に設定する必要があります。
また、C<SSL_ca> のリストとして (L<Net::SSLeay> または
L<IO::Socket::SSL::Utils> からの) X509* 証明書ハンドルを指定できます。
これらは、path と file の前に CA ストアに追加されるので、優先されます。
SSL_ca, SSL_ca_file, SSL_ca_path のいずれも設定されない場合、
ユーザー設定かシステムデフォルトかを決定するために C<default_ca()> を
使います。
本当に CA を設定したくない場合は、SSL_ca_file か SSL_ca_path に
C<\undef> を設定するか、SSL_ca に空リストを設定します。
(残念ながら C<''> は、CA が明示的に与えられなかったときに
IO::Socket::SSL を使った一部のモジュールによって使われています。)

=item SSL_fingerprint

=begin original

Sometimes you have a self-signed certificate or a certificate issued by an
unknown CA and you really want to accept it, but don't want to disable
verification at all. In this case you can specify the fingerprint of the
certificate as C<'algo$hex_fingerprint'>. C<algo> is a fingerprint algorithm
supported by OpenSSL, e.g. 'sha1','sha256'... and C<hex_fingerprint> is the
hexadecimal representation of the binary fingerprint.
To get the fingerprint of an established connection you can use
C<get_fingerprint>.

=end original

自己署名証明書または不明なCAによって発行された証明書があり、それを受け入れたいが、検証を無効にしたくない場合があります。
この場合、証明書のフィンガープリントをC<'algo$hex_fingerprint'>として指定できます。
C<algo>はOpenSSLでサポートされているフィンガープリントアルゴリズムです(例:'sha1'、'sha256'...)。
C<hex_fingerprint>はバイナリフィンガープリントの16進表現です。
確立された接続のフィンガープリントを取得するには、C<get_fingerprint>を使用できます。
(TBR)

=begin original

You can specify a list of fingerprints in case you have several acceptable
certificates.
If a fingerprint matches the topmost certificate no additional validations
can make the verification fail.

=end original

複数の受け入れ可能な証明書がある場合は、フィンガープリントのリストを指定できます。
フィンガープリントが最上位の証明書と一致する場合、追加の検証によって検証が失敗することはありません。
(TBR)

=item SSL_cert_file | SSL_cert | SSL_key_file | SSL_key

=begin original

If you create a server you usually need to specify a server certificate which
should be verified by the client. Same is true for client certificates, which
should be verified by the server.
The certificate can be given as a file with SSL_cert_file or as an internal
representation of a X509* object with SSL_cert.
If given as a file it will automatically detect the format.
Supported file formats are PEM, DER and PKCS#12, where PEM and PKCS#12 can
contain the certicate and the chain to use, while DER can only contain a single
certificate.

=end original

サーバーを作成する場合は、通常、クライアントによって検証されるサーバー証明書を指定する必要があります。
サーバーによって検証されるクライアント証明書についても同様です。
証明書は、SSL_cert_fileを使用してファイルとして指定するか、SSL_certを使用してX509*オブジェクトの内部表現として指定できます。
ファイルとして指定すると、フォーマットが自動的に検出されます。
サポートされているファイルフォーマットは、PEM、DERおよびPKCS#12です。
PEMおよびPKCS#12には、使用する証明書およびチェーンを含めることができますが、DERに含めることができる証明書は1つのみです。
(TBR)

=begin original

If given as a list of X509* please note, that the all the chain certificates
(e.g. all except the first) will be "consumed" by openssl and will be freed
if the SSL context gets destroyed - so you should never free them yourself. But
the servers certificate (e.g. the first) will not be consumed by openssl and
thus must be freed by the application.

=end original

X509*のリストとして提供されている場合は、すべてのチェーン証明書(最初の証明書を除くすべての証明書)がopensslによって「消費」され、SSLコンテキストが破壊された場合に解放されることに注意してください。
そのため、自分で解放しないでください。
ただし、サーバ証明書(最初の証明書など)はopensslによって消費されないため、アプリケーションによって解放される必要があります。
(TBR)

=begin original

For each certificate a key is need, which can either be given as a file with
SSL_key_file or as an internal representation of a EVP_PKEY* object with
SSL_key.
If a key was already given within the PKCS#12 file specified by SSL_cert_file
it will ignore any SSL_key or SSL_key_file.
If no SSL_key or SSL_key_file was given it will try to use the PEM file given
with SSL_cert_file again, maybe it contains the key too.

=end original

各証明書にはキーが必要です。
キーは、SSL_key_fileを使用したファイルとして、またはSSL_keyを使用したEVP_PKEY*オブジェクトの内部表現として指定できます。
キーがSSL_cert_fileで指定されたPKCS#12ファイル内ですでに指定されている場合、SSL_keyまたはSSL_key_fileは無視されます。
SSL_keyまたはSSL_key_fileが指定されていない場合、SSL_cert_fileで指定されたPEMファイルを再度使用しようとします。
キーも含まれている可能性があります。
(TBR)

=begin original

If your SSL server should be able to use different certificates on the same IP
address, depending on the name given by SNI, you can use a hash reference
instead of a file with C<<hostname => cert_file>>.

=end original

SSLサーバが同じIPアドレスで異なる証明書を使用できるようにする必要がある場合は、SNIで指定された名前に応じて、C<<hostname =>cert_file>>のファイルの代わりにハッシュ参照を使用できます。
(TBR)

=begin original

In case certs and keys are needed but not given it might fall back to builtin
defaults, see "Defaults for Cert, Key and CA".

=end original

証明書と鍵が必要であるが、与えられていない場合、組み込みのデフォルトに戻る可能性があります。
「証明書、鍵、CAのデフォルト」を参照してください。
(TBR)

=begin original

Examples:

=end original

例:
(TBR)

 SSL_cert_file => 'mycert.pem',
 SSL_key_file => 'mykey.pem',

 SSL_cert_file => {
    "foo.example.org" => 'foo-cert.pem',
    "bar.example.org" => 'bar-cert.pem',
    # used when nothing matches or client does not support SNI
    '' => 'default-cert.pem',
 }
 SSL_key_file => {
    "foo.example.org" => 'foo-key.pem',
    "bar.example.org" => 'bar-key.pem',
    # used when nothing matches or client does not support SNI
    '' => 'default-key.pem',
 }

=item SSL_passwd_cb

=begin original

If your private key is encrypted, you might not want the default password prompt
from Net::SSLeay.  This option takes a reference to a subroutine that should
return the password required to decrypt your private key.

=end original

あなたの秘密鍵が暗号化されているならば、Net::SSLeay からのデフォルトのパスワード
プロンプトが望ましくないかもしれません。
このオプションは秘密鍵を復号化するために必要とされるパスワードを返す
サブループンへのリファレンスを取ります。

=item SSL_use_cert

=begin original

If this is true, it forces IO::Socket::SSL to use a certificate and key, even if
you are setting up an SSL client.  If this is set to 0 (the default), then you
will only need a certificate and key if you are setting up a server.

=end original

これが真だと、SSL クライアントをセットアップしているときでさえも
IO::Socket::SSL に証明書と鍵を使うよう強制させます。
これが0(デフォルト)に
設定されると、サーバとして設定したときにだけ、証明書と鍵が必要になります。

=begin original

SSL_use_cert will implicitly be set if SSL_server is set.
For convenience it is also set if it was not given but a cert was given for use
(SSL_cert_file or similar).

=end original

SSL_server が設定されると、SSL_use_cert は暗黙に設定されます。
便利のために、これが設定されなくても (SSL_cert_file などで)
使用する証明書が設定されると、設定されます。

=item SSL_version

=begin original

Sets the version of the SSL protocol used to transmit data.
'SSLv23' uses a handshake compatible with SSL2.0, SSL3.0 and TLS1.x, while
'SSLv2', 'SSLv3', 'TLSv1', 'TLSv1_1' or 'TLSv1_2' restrict handshake and
protocol to the specified version.
All values are case-insensitive.  Instead of 'TLSv1_1' and 'TLSv1_2' one can
also use 'TLSv11' and 'TLSv12'.  Support for 'TLSv1_1' and 'TLSv1_2' requires
recent versions of Net::SSLeay and openssl.

=end original

データを転送するために使われるSSLプロトコルのバージョンを設定します。
'SSLv23' は SSL2.0, SSL3.0, TLS1.x に互換性のあるハンドシェイクを使いますが、
'SSLv2', 'SSLv3', 'TLSv1', 'TLSv1_1', 'TLSv1_2' は
指定されたバージョンにハンドシェイクとプロトコルを制限します。
全ての値は大文字小文字を無視します。
'TLSv1_1' と 'TLSv1_2' の代わりに、
'TLSv11' と 'TLSv12' を使えます。
'TLSv1_1' と 'TLSv1_2' に対応するには最近のバージョンの
Net::SSLeay と openssl が必要です。

=begin original

Independend from the handshake format you can limit to set of accepted SSL
versions by adding !version separated by ':'.

=end original

ハンドシェイクとは独立して、
':' で区切られた!バージョンを追加することで、受け入れる SSL の
バージョンのセットを制限できます。

=begin original

The default SSL_version is 'SSLv23:!SSLv3:!SSLv2' which means, that the
handshake format is compatible to SSL2.0 and higher, but that the successful
handshake is limited to TLS1.0 and higher, that is no SSL2.0 or SSL3.0 because
both of these versions have serious security issues and should not be used
anymore.
You can also use !TLSv1_1 and !TLSv1_2 to disable TLS versions 1.1 and 1.2 while
still allowing TLS version 1.0.

=end original

デフォルトの SSL_version は 'SSLv23:!SSLv3:!SSLv2' です;
ハンドシェイク形式は SSL2.0 以上と互換性がありますが、
ハンドシェイクが成功するのは TLS1.0 以上に制限されます。
つまり SSL2.0 や SSL3.0 はありません;
これらは両方とも重大なセキュリティ問題があり、
もはや使うべきではないからです。
!TLSv1_1 と !TLSv1_2 を使用して、TLS バージョン 1.1 と 1.2 を無効にし、
まだ TLS バージョン 1.0 を許可することもできます。

=begin original

Setting the version instead to 'TLSv1' might break interaction with older
clients, which need and SSL2.0 compatible handshake. On the other
side some clients just close the connection when they receive a TLS version 1.1
request. In this case setting the version to
'SSLv23:!SSLv2:!SSLv3:!TLSv1_1:!TLSv1_2' might help.

=end original

代わりにバージョンを 'TLSv1' に設定すると、SSL2.0 互換のハンドシェイクが
必要な古いクライアントとの相互作用が失われる可能性があります。
一方、一部のクライアントは、TLS バージョン 1.1 要求を受信したときに
接続を閉じるだけです。
この場合、バージョンを 'SSLv23:!SSLv2:!SSLv3:!TLSv1_1:!TLSv1_2' に設定すると
役立つ場合があります。

=item SSL_cipher_list

=begin original

If this option is set the cipher list for the connection will be set to the
given value, e.g. something like 'ALL:!LOW:!EXP:!aNULL'. Look into the OpenSSL
documentation (L<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>)
for more details.

=end original

このオプションが設定されると、接続のための暗号リストが指定された値になります;
つまり、'ALL:!LOW:!EXP:!aNULL' のようなものです。
さらなる詳細については、OpenSSL の文書
(L<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>) を
参照してください。

=begin original

Unless you fail to contact your peer because of no shared ciphers it is
recommended to leave this option at the default setting. The default setting
prefers ciphers with forward secrecy, disables anonymous authentication and
disables known insecure ciphers like MD5, DES etc. This gives a grade A result
at the tests of SSL Labs.
To use the less secure OpenSSL builtin default (whatever this is) set
SSL_cipher_list to ''.

=end original

共通の暗号がないために相手先との接続が失敗する場合を除いて、
このオプションをデフォルト設定のままにすることを勧めます。
デフォルト設定は前方秘匿性をもつ暗号を優先し、
無名認証を無効化し、MD5, DES などの安全でないことが知られている暗号を
無効化します。
これは SSL Labs のテストでグレード A を取っています。
安全性の低い OpenSSL 組み込みのデフォルト(これが何であれ)を使用するには、
SSL_cipher_list に '' を設定します。

=item SSL_honor_cipher_order

=begin original

If this option is true the cipher order the server specified is used instead
of the order proposed by the client. This option defaults to true to make use of
our secure cipher list setting.

=end original

このオプションが真の場合、クライアントによって提示された順序ではなく、
サーバが指定した暗号順序が使用されます。
このオプションのデフォルトは真で、私たちのセキュアな暗号リスト設定を
使います。

=item SSL_dh_file

=begin original

If you want Diffie-Hellman key exchange you need to supply a suitable file here
or use the SSL_dh parameter. See dhparam command in openssl for more
information.
To create a server which provides forward secrecy you need to either give the DH
parameters or (better, because faster) the ECDH curve.

=end original

Diffie-Hellman 鍵交換を行いたい場合、ここで適切なファイルを指定するか
SSL_dh 引数を使う必要があります。
さらなる情報については openssl の dhparam コマンドを参照してください。
前方秘匿性を持つサーバを作るには、
DH 引数か、(より高速なのでより好ましい) ECDH 曲線のどちらかを
指定する必要があります。

=begin original

If neither C<SSL_dh_file> not C<SSL_dh> is set a builtin DH parameter with a
length of 2048 bit is used to offer DH key exchange by default. If you don't
want this (e.g. disable DH key exchange) explicitly set this or the C<SSL_dh>
parameter to undef.

=end original

C<SSL_dh_file>とC<SSL_dh>のどちらも設定されていない場合、デフォルトでは、長さが2048ビットの組み込みDHパラメータを使用してDHキー交換が提供されます。
これを望まない場合(DHキー交換を無効にするなど)は、明示的にこれを設定するか、C<SSL_dh>パラメータをundefに設定します。
(TBR)

=item SSL_dh

=begin original

Like SSL_dh_file, but instead of giving a file you use a preloaded or generated
DH*.

=end original

SSL_dh_file と同様ですが、ファイルを指定する代わりに事前に読み込んだか
生成した DH* を使います。

=item SSL_ecdh_curve

=begin original

If you want Elliptic Curve Diffie-Hellmann key exchange you need to supply the
OID or NID of a suitable curve (like 'prime256v1') here.
To create a server which provides forward secrecy you need to either give the DH
parameters or (better, because faster) the ECDH curve.

=end original

Elliptic Curve Diffie-ヘルマン鍵交換が必要な場合は、適切な曲線('prime256v1'など)のOIDまたはNIDをここで指定する必要があります。
前方秘匿性を提供するサーバを作成するには、DHパラメータを指定するか、ECDH曲線(高速なので優れています)を指定する必要があります。
(TBR)

=begin original

This parameter defaults to 'prime256v1' (builtin of OpenSSL) to offer ECDH key
exchange by default. If you don't want this explicitly set it to undef.

=end original

このパラメータのデフォルトは'prime256v1'(OpenSSLの組み込み)で、デフォルトでECDH鍵交換を提供します。
これを明示的に望まない場合は、undefに設定してください。
(TBR)

=begin original

You can check if ECDH support is available by calling
C<IO::Socket::SSL->can_ecdh>.

=end original

ECDHサポートが利用可能かどうかは、C<IO::Socket::SSL->can_ecdh>を呼び出すことで確認できます。
(TBR)

=item SSL_verify_mode

=begin original

This option sets the verification mode for the peer certificate.
You may combine SSL_VERIFY_PEER (verify_peer), SSL_VERIFY_FAIL_IF_NO_PEER_CERT
(fail verification if no peer certificate exists; ignored for clients),
SSL_VERIFY_CLIENT_ONCE (verify client once; ignored for clients).
See OpenSSL man page for SSL_CTX_set_verify for more information.

=end original

このオプションは相手の証明書のための確認モードを設定します。
SSL_VERIFY_PEER (相手を確認), SSL_VERIFY_FAIL_IF_NO_PEER_CERT
(相手の証明書がなければ確認失敗;クライアントに対しては無視),
SSL_VERIFY_CLIENT_ONCE (一度、クライアントは確認;
クライアントに対しては無視) を組み合わせることができます。
さらなる情報については OpenSSL man ページの SSL_CTX_set_verify を
参照してください。

=begin original

The default is SSL_VERIFY_NONE for server  (e.g. no check for client
certificate) and SSL_VERIFY_PEER for client (check server certificate).

=end original

デフォルトは、サーバーの場合はSSL_VERIFY_NONE(クライアント証明書のチェックなしなど)、クライアントの場合はSSL_VERIFY_PEER(サーバー証明書のチェック)です。
(TBR)

=item SSL_verify_callback

=begin original

If you want to verify certificates yourself, you can pass a sub reference along
with this parameter to do so.  When the callback is called, it will be passed:

=end original

証明書を自分で検証する場合は、このパラメータとともにサブルーチン参照を渡して
検証できます。
コールバックが呼び出されると、次のものが渡されます:

=over 4

=item 1.
a true/false value that indicates what OpenSSL thinks of the certificate,

(OpenSSL が証明書について認識している内容を示す真偽値)

=item 2.
a C-style memory address of the certificate store,

(証明書ストアの C 形式のメモリアドレス)

=item 3.
a string containing the certificate's issuer attributes and owner attributes,
and

(証明書の発行者属性と所有者属性を含む文字列)

=item 4.
a string containing any errors encountered (0 if no errors).

(発生したエラーを含む文字列(エラーがない場合は 0))

=item 5.
a C-style memory address of the peer's own certificate (convertible to
PEM form with Net::SSLeay::PEM_get_string_X509()).

(相手自身の証明書の C 形式のメモリアドレス (Net::SSLeay::PEM_get_string_X509() で PEM 形式に変換可能))

=back

=begin original

The function should return 1 or 0, depending on whether it thinks the
certificate is valid or invalid.  The default is to let OpenSSL do all of the
busy work.

=end original

この関数は、証明書が有効であると認識しているか無効であると
認識しているかに応じて、1 または 0 を返します。
デフォルトでは、OpenSSL が忙しい作業をすべて実行します。

=begin original

The callback will be called for each element in the certificate chain.

=end original

コールバックは、証明書チェーン内の各要素に対して呼び出されます。

=begin original

See the OpenSSL documentation for SSL_CTX_set_verify for more information.

=end original

SSL_CTX_set_verify の詳細については、OpenSSL のマニュアルを参照してください。

=item SSL_verifycn_scheme

=begin original

The scheme is used to correctly verify the identity inside the certificate
by using the hostname of the peer.
See the information about the verification schemes in B<verify_hostname>.

=end original

スキーマは、ピアのホスト名を使うことによって、証明書の中の
身元を検証するために使われます。
B<verify_hostname> の検証スキームに関する情報を参照してください。

=begin original

If you don't specify a scheme it will use 'default', but only complain loudly if
the name verification fails instead of letting the whole certificate
verification fail. THIS WILL CHANGE, e.g. it will let the certificate
verification fail in the future if the hostname does not match the certificate
!!!!  To override the name used in verification use B<SSL_verifycn_name>.

=end original

スキームを指定しない場合は、'default'を使用しますが、証明書全体の検証を失敗させるのではなく、名前の検証が失敗した場合にのみ大声で文句を言います。
これは変更されます。
たとえば、ホスト名が証明書と一致しない場合は、将来証明書の検証を失敗させます。
検証で使用される名前を上書きするには、B<SSL_verifycn_name>を使用します。
(TBR)

=begin original

The scheme 'default' is a superset of the usual schemes, which will accept the
hostname in common name and subjectAltName and allow wildcards everywhere.
While using this scheme is way more secure than no name verification at all you
better should use the scheme specific to your application protocol, e.g. 'http',
'ftp'...

=end original

'default'スキームは通常のスキームのスーパーセットであり、共通名とsubjectAltNameのホスト名を受け入れ、どこでもワイルドカードを許可します。
このスキームを使用することは、名前の検証をまったく行わないよりもはるかに安全ですが、'http'、'ftp'...のようなアプリケーションプロトコルに固有のスキームを使用する方が良いでしょう。
(TBR)

=begin original

If you are really sure, that you don't want to verify the identity using the
hostname  you can use 'none' as a scheme. In this case you'd better have
alternative forms of verification, like a certificate fingerprint or do a manual
verification later by calling B<verify_hostname> yourself.

=end original

本当にホスト名を使用して身元を確認したくない場合は、スキームとして「none」を使用できます。
この場合は、証明書のフィンガープリントなどの別の形式の確認を行うか、後で自分でB<verify_hostname>を呼び出して手動で確認することをお勧めします。
(TBR)

=item SSL_verifycn_publicsuffix

=begin original

This option is used to specify the behavior when checking wildcards certificates
for public suffixes, e.g. no wildcard certificates for *.com or *.co.uk should
be accepted, while *.example.com or *.example.co.uk is ok.

=end original

このオプションは、公開サフィックスのワイルドカード証明書をチェックするときの動作を指定するために使用されます。
たとえば、*.comまたは*.co.ukのワイルドカード証明書は受け入れられませんが、*.example.comまたは*.example.co.ukは受け入れられます。
(TBR)

=begin original

If not specified it will simply use the builtin default of
L<IO::Socket::SSL::PublicSuffix>, you can create another object with
from_string or from_file of this module.

=end original

指定しない場合は、組み込みのデフォルトであるL<IO::Socket::SSL::PublicSuffix>が使用されます。
このモジュールのfrom_stringまたはfrom_fileを使用して、別のオブジェクトを作成できます。
(TBR)

=begin original

To disable verification of public suffix set this option to C<''>.

=end original

パブリックサフィックスの検証を無効にするには、このオプションをC<''>に設定します。
(TBR)

=item SSL_verifycn_name

=begin original

Set the name which is used in verification of hostname. If SSL_verifycn_scheme
is set and no SSL_verifycn_name is given it will try to use SSL_hostname or
PeerHost and PeerAddr settings and fail if no name can be determined.
If SSL_verifycn_scheme is not set it will use a default scheme and warn if it
cannot determine a hostname, but it will not fail.

=end original

ホスト名の検証に使用される名前を設定します。
SSL_verifycn_scheme が設定されていて、SSL_verifycn_name が
指定されていない場合、SSL_hostname または PeerHost と PeerAddr の設定を
使用しようとしますが、名前が決定できない場合は失敗します。
SSL_verifycn_scheme が設定されていない場合はデフォルトのスキームを使い、
ホスト名が決定できない場合は警告されますが、失敗はしません。

=begin original

Using PeerHost or PeerAddr works only if you create the connection directly
with C<< IO::Socket::SSL->new >>, if an IO::Socket::INET object is upgraded
with B<start_SSL> the name has to be given in B<SSL_verifycn_name> or
B<SSL_hostname>.

=end original

PeerHost または PeerAddr の使用は、C<< IO::Socket::SSL->new >> で
直接接続を作成する場合にのみ機能します;
IO::Socket::INET オブジェクトが B<start_SSL> でアップグレードされる場合、
名前は B<SSL_verifycn_name> または B<SSL_hostname> で指定する必要があります。

=item SSL_check_crl

=begin original

If you want to verify that the peer certificate has not been revoked
by the signing authority, set this value to true. OpenSSL will search
for the CRL in your SSL_ca_path, or use the file specified by
SSL_crl_file.  See the Net::SSLeay documentation for more details.
Note that this functionality appears to be broken with OpenSSL <
v0.9.7b, so its use with lower versions will result in an error.

=end original

ピア証明書が署名機関によって取り消されていないことを確認する場合は、
この値を真に設定します;
OpenSSL は SSL_ca_path で CRL を検索するか、SSL_crl_file で
指定されたファイルを使用します。
詳細は、Net::SSLeay の文書を参照してください。
この機能は OpenSSL < v0.9.7b では壊れているように見えるため、
下位バージョンで使用するとエラーが発生することに注意してください。

=item SSL_crl_file

=begin original

If you want to specify the CRL file to be used, set this value to the
pathname to be used.  This must be used in addition to setting
SSL_check_crl.

=end original

使用する CRL ファイルを指定する場合は、この値を使用するパス名に設定します。
これは、SSL_check_crl の設定に加えて使用する必要があります。

=item SSL_ocsp_mode

=begin original

Defines how certificate revocation is done using OCSP (Online Status Revocation
Protocol). The default is to send a request for OCSP stapling to the server and
if the server sends an OCSP response back the result will be used.

=end original

OCSP(オンライン状態失効プロトコル)を使用して証明書の失効を行う方法を定義します。
既定では、OCSPホチキス止めの要求をサーバーに送信し、サーバーがOCSP応答を返した場合、その結果が使用されます。
(TBR)

=begin original

Any other OCSP checking needs to be done manually with C<ocsp_resolver>.

=end original

その他のOCSPチェックは、C<ocsp_resolver>を使用して手動で行う必要があります。
(TBR)

=begin original

The following flags can be combined with C<|>:

=end original

次のフラグはC<|>と組み合わせることができます。
(TBR)

=over 8

=item SSL_OCSP_NO_STAPLE

=begin original

Don't ask for OCSP stapling.
This is the default if SSL_verify_mode is VERIFY_NONE.

=end original

OCSPステープルを要求しないでください。
これは、SSL_verify_modeがVERIFY_NONEの場合のデフォルトです。
(TBR)

=item SSL_OCSP_TRY_STAPLE

=begin original

Try OCSP stapling, but don't complain if it gets no stapled response back.
This is the default if SSL_verify_mode is VERIFY_PEER (the default).

=end original

OCSPホチキス止めを試してみても、ホチキス止めの応答が返ってこなくても文句を言わないでください。
これは、SSL_verify_modeがVERIFY_PEER(デフォルト)の場合のデフォルトです。
(TBR)

=item SSL_OCSP_MUST_STAPLE

=begin original

Consider it a hard error, if the server does not send a stapled OCSP response
back. Most servers currently send no stapled OCSP response back.

=end original

サーバーがホチキス止めされたOCSP応答を返信しない場合は、ハードエラーと見なします。
現在、ほとんどのサーバーはホチキス止めされたOCSP応答を返信しません。
(TBR)

=item SSL_OCSP_FAIL_HARD

=begin original

Fail hard on response errors, default is to fail soft like the browsers do.
Soft errors mean, that the OCSP response is not usable, e.g. no response,
error response, no valid signature etc.
Certificate revocations inside a verified response are considered hard errors
in any case.

=end original

応答エラーで失敗すると、デフォルトではブラウザと同様にフェイルソフトになります。
ソフトエラーとは、OCSP応答が使用できないことを意味します。
たとえば、応答がない、エラー応答、有効な署名がないなどです。
検証された応答内での証明書の失効は、いかなる場合でもハードエラーと見なされます。
(TBR)

=begin original

Soft errors inside a stapled response are never considered hard, e.g. it is
expected that in this case an OCSP request will be send to the responsible
OCSP responder.

=end original

ステープルされた応答内のソフトエラーは、決してハードとは見なされない。
例えば、この場合、OCSP要求が責任のあるOCSPレスポンダに送信されることが期待される。
(TBR)

=item SSL_OCSP_FULL_CHAIN

=begin original

This will set up the C<ocsp_resolver> so that all certificates from the peer
chain will be checked, otherwise only the leaf certificate will be checked
against revocation.

=end original

これは、C<ocsp_resolver>を設定して、ピアチェーンからのすべての証明書がチェックされるようにします。
そうでなければ、リーフ証明書のみが失効に対してチェックされます。
(TBR)

=back

=item SSL_ocsp_staple_callback

=begin original

If this callback is defined, it will be called with the SSL object and the OCSP
response handle obtained from the peer, e.g. C<<$cb->($ssl,$resp)>>.
If the peer did not provide a stapled OCSP response the function will be called
with C<$resp=undef>.
Because the OCSP response handle is no longer valid after leaving this function
it should not by copied or freed. If access to the response is necessary after
leaving this function it can be serialized with
C<Net::SSLeay::i2d_OCSP_RESPONSE>.

=end original

このコールバックが定義されている場合は、C<<$cb->($ssl,$resp)>>のように、ピアから取得したSSLオブジェクトとOCSP応答ハンドルを使用して呼び出されます。
ピアがステープルされたOCSP応答を提供しなかった場合は、C<$resp=undef>を使用して関数が呼び出されます。
OCSP応答ハンドルは、この関数を終了すると無効になるため、コピーまたは解放しないでください。
この関数を終了した後に応答へのアクセスが必要な場合は、C<Net::SSLeay::i2d_OCSP_RESPONSE>を使用してシリアル化できます。
(TBR)

=begin original

If no such callback is provided, it will use the default one, which verifies the
response and uses it to check if the certificate(s) of the connection got
revoked.

=end original

そのようなコールバックが提供されない場合は、デフォルトのコールバックが使用されます。
このコールバックは応答を確認し、接続の証明書が取り消されたかどうかを確認するために使用されます。
(TBR)

=item SSL_ocsp_cache

=begin original

With this option a cache can be given for caching OCSP responses, which could
be shared between different SSL contextes. If not given a cache specific to the
SSL context only will be used.

=end original

このオプションを使用すると、異なるSSLコンテキスト間で共有できるOCSP応答をキャッシュするためのキャッシュを指定できます。
指定しない場合は、SSLコンテキストに固有のキャッシュのみが使用されます。
(TBR)

=begin original

You can either create a new cache with
C<<IO::Socket::SSL::OCSP_Cache->new([size]) >> or implement your own cache,
which needs to have methods C<put($key,\%entry)> and C<get($key)->\%entry>
where entry is the hash representation of the OCSP response with fields like
C<nextUpdate>. The default implementation of the cache will consider responses
valid as long as C<nextUpdate> is less then the current time.

=end original

C<<IO::Socket::SSL::OCSP_Cache->new([size])>>を使用して新しいキャッシュを作成することも、独自のキャッシュを実装することもできます。
独自のキャッシュを実装するには、C<put($key,\%entry)>メソッドとC<get($key)->\%entry>メソッドを使用する必要があります。
entryは、C<nextUpdate>のようなフィールドを持つOCSP応答のハッシュ表現です。
キャッシュのデフォルトの実装では、C<nextUpdate>が現在の時間より短い限り、応答が有効であると見なされます。
(TBR)

=item SSL_reuse_ctx

=begin original

If you have already set the above options for a previous instance of
IO::Socket::SSL, then you can reuse the SSL context of that instance by passing
it as the value for the SSL_reuse_ctx parameter.  You may also create a
new instance of the IO::Socket::SSL::SSL_Context class, using any context
options that you desire without specifying connection options, and pass that
here instead.

=end original

上記のオプションを、IO::Socket::SSL の前のインスタンスのために
設定していれば、それを SSL_reuse_ctx パラメータの値として渡すことにより、
そのインスタンスの SSL コンテキストを再利用することができます。
また、接続オプションを指定せずに、ここで渡すことで、
望みのコンテキストオプションを使った IO::Socket::SSL::SSL_Context クラスの
新しいインスタンスを作ることもできます。

=begin original

If you use this option, all other context-related options that you pass
in the same call to new() will be ignored unless the context supplied was
invalid.  Note that, contrary to versions of IO::Socket::SSL below v0.90, a
global SSL context will not be implicitly used unless you use the
set_default_context() function.

=end original

このオプションを使うと、new() への同じ呼び出しで渡した、コンテキストに関連した
その他全てのオプションは、渡されたコンテキストが無効でない限り、無視されます。
v0.90 より前の IO::Socket::SSL とは反対に、set_default_context() 関数を
使わない限り、グローバルな SSL コンテキストは暗黙のうちには
使われないことに注意してください。

=item SSL_create_ctx_callback

=begin original

With this callback you can make individual settings to the context after it
got created and the default setup was done.
The callback will be called with the CTX object from Net::SSLeay as the single
argument.

=end original

このコールバックを使用すると、コンテキストが作成され、
デフォルトの設定が完了した後に、コンテキストに対して
個別の設定を行うことができます。
コールバックは、Net::SSLeay からの CTX オブジェクトを
単一の引数として呼び出します。

=begin original

Example for limiting the server session cache size:

=end original

サーバーセッションのキャッシュサイズを制限する例:

  SSL_create_ctx_callback => sub {
      my $ctx = shift;
      Net::SSLeay::CTX_sess_set_cache_size($ctx,128);
  }

=item SSL_session_cache_size

=begin original

If you make repeated connections to the same host/port and the SSL renegotiation
time is an issue, you can turn on client-side session caching with this option
by specifying a positive cache size.  For successive connections, pass the
SSL_reuse_ctx option to the new() calls (or use set_default_context()) to make
use of the cached sessions.  The session cache size refers to the number of
unique host/port pairs that can be stored at one time; the oldest sessions in
the cache will be removed if new ones are added.

=end original

同じホスト/ポートに繰り返し接続し、SSL 再ネゴシエーション時間が
問題になる場合は、正のキャッシュサイズを指定して、このオプションで
クライアント側のセッションキャッシュをオンにできます。
連続した接続の場合は、SSL_reuse_ctx オプションを new() 呼び出しに渡して
(または set_default_context() を使用して)、
キャッシュされたセッションを利用します。
セッションキャッシュサイズは、一度に格納できる一意の
ホスト/ポートペアの数を示します;
新しいセッションが追加されると、キャッシュ内の
最も古いセッションが削除されます。

=begin original

This option does not effect the session cache a server has for it's clients,
e.g. it does not affect SSL objects with SSL_server set.

=end original

このオプションは、サーバーがそのクライアントに対して持っている
セッションキャッシュには影響しません;
たとえば、SSL_server が設定されている SSL オブジェクトには影響しません。

=item SSL_session_cache

=begin original

Specifies session cache object which should be used instead of creating a new.
Overrules SSL_session_cache_size.
This option is useful if you want to reuse the cache, but not the rest of
the context.

=end original

新規作成のかわりに使用するセッションキャッシュオブジェクトを指定します。
SSL_session_cache_size を上書きします。
このオプションは、キャッシュを再利用するが、残りのコンテキストは
再利用しない場合に便利です。

=begin original

A session cache object can be created using
C<< IO::Socket::SSL::Session_Cache->new( cachesize ) >>.

=end original

セッションキャッシュオブジェクトは、
C<< IO::Socket::SSL::Session_Cache->new(cachesize)>> を使って作成できます。

=begin original

Use set_default_session_cache() to set a global cache object.

=end original

グローバルキャッシュオブジェクトを設定するには、
set_default_session_cache() を使用します。

=item SSL_session_key

=begin original

Specifies a key to use for lookups and inserts into client-side session cache.
Per default ip:port of destination will be used, but sometimes you want to
share the same session over multiple ports on the same server (like with FTPS).

=end original

クライアント側のセッションキャッシュへの参照および挿入に使用するキーを指定します。
デフォルトでは宛先のip:portが使用されますが、(FTPSのように)同じサーバー上の複数のポートで同じセッションを共有したい場合もあります。
(TBR)

=item SSL_session_id_context

=begin original

This gives an id for the servers session cache. It's necessary if you want
clients to connect with a client certificate. If not given but SSL_verify_mode
specifies the need for client certificate a context unique id will be picked.

=end original

これにより、サーバーのセッションキャッシュの ID が指定されます。
これは、クライアントがクライアント証明書を使用して接続する場合に必要です。
指定されていない場合でも、SSL_verify_mode がクライアント証明書の必要性を
指定している場合は、コンテキスト固有の ID が選択されます。

=item SSL_error_trap

=begin original

When using the accept() or connect() methods, it may be the case that the
actual socket connection works but the SSL negotiation fails, as in the case of
an HTTP client connecting to an HTTPS server.  Passing a subroutine ref attached
to this parameter allows you to gain control of the orphaned socket instead of
having it be closed forcibly.
The subroutine, if called, will be passed two parameters:
a reference to the socket on which the SSL negotiation failed and the full
text of the error message.

=end original

accept() または connect() メソッドを使用する場合、HTTP クライアントが
HTTPS サーバーに接続する場合のように、実際のソケット接続は機能するが、
SSL ネゴシエーションが失敗する場合があります。
このパラメータに付加されたサブルーチンリファレンスを渡すと、
強制的に閉じるのではなく、孤立したソケットを制御できます。
サブルーチンが呼び出されると、二つのパラメータが渡されます:
一つは SSL ネゴシエーションが失敗したソケットへの参照で、もう1つは
エラーメッセージの全文です。

=item SSL_npn_protocols

=begin original

If used on the server side it specifies list of protocols advertised by SSL
server as an array ref, e.g. ['spdy/2','http1.1'].
On the client side it specifies the protocols offered by the client for NPN
as an array ref.
See also method C<next_proto_negotiated>.

=end original

サーバ側で使用する場合は、SSL サーバによってアドバタイズされるプロトコルの
リストを配列リファレンスとして指定します(例: ['spdy/2','http1.1'])。
クライアント側では、クライアントが NPN 用に提供するプロトコルを
配列リファレンスとして指定します。
C<next_proto_negotiated> メソッドも参照してください。

=begin original

Next Protocol Negotioation (NPN) is available with Net::SSLeay 1.46+ and
openssl-1.0.1+.
To check support you might call C<IO::Socket::SSL->can_npn()>.
If you use this option with an unsupported Net::SSLeay/OpenSSL it will
throw an error.

=end original

Next Protocol Negotiation(NPN) は、Net::SSLeay 1.46+ および
openssl-1.0.1+ で使用できます。
サポートをチェックするためには、C<IO::Socket::SSL->can_npn()> を
呼び出せます。
未対応の Net::SSLeay/OpenSSL でこのオプションを使うと、
エラーが投げられます。

=back

=item B<accept>

=begin original

This behaves similar to the accept function of the underlying socket class, but
additionally does the initial SSL handshake. But because the underlying socket
class does return a blocking file handle even when accept is called on a
non-blocking socket, the SSL handshake on the new file object will be done in a
blocking way. Please see the section about non-blocking I/O for details.
If you don't like this behavior you should do accept on the TCP socket and then
upgrade it with C<start_SSL> later.

=end original

これは、基礎となるソケットクラスのaccept関数に似た動作をしますが、さらに最初のSSLハンドシェイクも行います。
しかし、基礎となるソケットクラスは、非ブロッキングソケットでacceptが呼び出された場合でもブロッキングファイルハンドルを返すため、新しいファイルオブジェクトでのSSLハンドシェイクはブロッキング方式で行われます。
詳細については、非ブロッキングI/Oに関するセクションを参照してください。
この動作が気に入らない場合は、TCPソケットでacceptを実行し、後でC<start_SSL>でアップグレードする必要があります。
(TBR)

=item B<connect(...)>

=begin original

This behaves similar to the connnect function but also does an SSL handshake.
Because you cannot give SSL specific arguments to this function, you should
better either use C<new> to create a connect SSL socket or C<start_SSL> to
upgrade an established TCP socket to SSL.

=end original

この関数はconnnect関数と同様に動作しますが、SSLハンドシェイクも行います。
この関数にはSSL固有の引数を指定できないため、C<new>を使用して接続SSLソケットを作成するか、C<start_SSL>を使用して確立されたTCPソケットをSSLにアップグレードすることをお薦めします。
(TBR)

=item B<close(...)>

=begin original

There are a number of nasty traps that lie in wait if you are not careful about
using close().  The first of these will bite you if you have been using
shutdown() on your sockets.  Since the SSL protocol mandates that a SSL "close
notify" message be sent before the socket is closed, a shutdown() that closes
the socket's write channel will cause the close() call to hang.  For a similar
reason, if you try to close a copy of a socket (as in a forking server) you will
affect the original socket as well.
To get around these problems, call close with an object-oriented syntax
(e.g. $socket->close(SSL_no_shutdown => 1))
and one or more of the following parameters:

=end original

close() を使うことについて注意しなければ、wait に関連していくつかの
やっかいな罠があります。
まず最初にソケットで shutdown() を使っていると、これにより
困ったことになります。
SSL プロトコルはソケットをクローズ前に SSL "close notify" メッセージが
送信されるよう権限を与え、ソケットの書込みチャネルをクローズする
shutdown() は close() 呼び出しをハングさせてしまいます。
同じような理由で、(サーバを fork するとき)ソケットのコピーを
close しようとすると、元のソケットにも影響を与えます。
これらの問題を回避するため、
以下のパラメータの 1 つあるいは複数でオブジェクト指向の書き方
(例えば socket->close(SSL_no_shutdown => 1)) で close() を
呼び出してください。

=over 2

=item SSL_no_shutdown

=begin original

If set to a true value, this option will make close() not use the SSL_shutdown()
call on the socket in question so that the close operation can complete without
problems if you have used shutdown() or are working on a copy of a socket.

=end original

true 値に設定すると、このオプションは、shutdown() やソケットのコピーで
動いているならば、close() に、close 操作が問題なく完了できるよう、
疑わしいソケットに対して SSL_shutdown() を使わないようにさせます。

=begin original

Not using a real ssl shutdown on a socket will make session caching unusable.

=end original

ソケット上で実際のsslシャットダウンを使用しないと、セッションキャッシングが使用できなくなります。
(TBR)

=item SSL_fast_shutdown

=begin original

If set to true only a unidirectional shutdown will be done, e.g. only the
close_notify (see SSL_shutdown(3)) will be sent. Otherwise a bidirectional
shutdown will be done where it waits for the close_notify of the peer too.

=end original

真に設定した場合、一方向のシャットダウンのみが行われます;
例えば、close_notify(SSL_shutdown(3) を参照)のみが送られます。
それ以外の場合は、双方向のシャットダウンが行われます;
相手側の close_notify も待ちます。

=begin original

Because a unidirectional shutdown is enough to keep session cache working it
defaults to fast shutdown inside close.

=end original

単一方向のシャットダウンはセッションキャッシュの動作を維持するのに十分であるため、デフォルトでは内部クローズの高速シャットダウンになります。
(TBR)

=item SSL_ctx_free

=begin original

If you want to make sure that the SSL context of the socket is destroyed when
you close it, set this option to a true value.

=end original

それをクローズするとき、そのソケットの SSL コンテキストが破壊されることを
確実にしたければ、このオプションを true 値に設定してください。

=back

=item B<sysread( BUF, LEN, [ OFFSET ] )>

=begin original

This function behaves from the outside the same as B<sysread> in other
L<IO::Socket> objects, e.g. it returns at most LEN bytes of data.
But in reality it reads not only LEN bytes from the underlying socket, but at
a single SSL frame. It then returns up to LEN bytes it decrypted from this SSL
frame. If the frame contained more data than requested it will return only LEN
data, buffer the rest and return it on further read calls.
This means, that it might be possible to read data, even if the underlying
socket is not readable, so using poll or select might not be sufficient.

=end original

この関数は、外部からは他のL<IO::Socket>オブジェクトのB<sysread>と同じように動作します。
たとえば、最大LENバイトのデータを返します。
しかし、実際には、基礎となるソケットからLENバイトだけを読み取るのではなく、単一のSSLフレームで読み取ります。
次に、このSSLフレームから復号化された最大LENバイトを返します。
フレームに要求されたよりも多くのデータが含まれている場合は、LENデータのみを返し、残りをバッファリングして、その後の読み取り呼び出しで返します。
つまり、基礎となるソケットが読み取り可能でなくてもデータを読み取ることができるため、pollまたはselectを使用するだけでは不十分な場合があります。
(TBR)

=begin original

sysread will only return data from a single SSL frame, e.g. either the pending
data from the already buffered frame or it will read a frame from the underlying
socket and return the decrypted data. It will not return data spanning several
SSL frames in a single call.

=end original

sysreadは、単一のSSLフレームからのデータのみを返します。
たとえば、すでにバッファされているフレームからの保留中のデータを返すか、基礎となるソケットからフレームを読み取って復号化されたデータを返します。
1回の呼び出しで複数のSSLフレームにまたがるデータを返すことはありません。
(TBR)

=begin original

Also, calls to sysread might fail, because it must first finish an SSL
handshake.

=end original

また、sysreadの呼び出しは、最初にSSLハンドシェイクを完了する必要があるため、失敗する可能性があります。
(TBR)

=begin original

To understand these behaviors is essential, if you write applications which use
event loops and/or non-blocking sockets. Please read the specific sections in
this documentation.

=end original

これらの動作を理解することは、イベントループや非ブロッキングソケットを使用するアプリケーションを作成する場合に不可欠です。
この文書の特定のセクションをお読みください。
(TBR)

=item B<syswrite( BUF, [ LEN, [ OFFSET ]] )>

=begin original

This functions behaves from the outside the same as B<syswrite> in other
L<IO::Socket> objects, e.g. it will write at most LEN bytes to the socket, but
there is no guarantee, that all LEN bytes are written. It will return the number
of bytes written.
syswrite will write all the data within a single SSL frame, which means, that
no more than 16.384 bytes, which is the maximum size of an SSL frame, can be
written at once.

=end original

この関数は、外部からは他のL<IO::Socket>オブジェクトのB<syswrite>と同じように動作します。
たとえば、最大LENバイトをソケットに書き込みますが、すべてのLENバイトが書き込まれるという保証はありません。
書き込まれたバイト数を返します。
syswriteは、1つのSSLフレーム内のすべてのデータを書き込みます。
つまり、一度に書き込むことができるのは、SSLフレームの最大サイズである16.384バイトまでです。
(TBR)

=begin original

For non-blocking sockets SSL specific behavior applies.
Pease read the specific section in this documentation.

=end original

非ブロッキングソケットの場合、SSL固有の動作が適用されます。
この文書の特定のセクションをお読みください。
(TBR)

=item B<peek( BUF, LEN, [ OFFSET ])>

=begin original

This function has exactly the same syntax as B<sysread>, and performs nearly the
same task but will not advance the read position so that successive calls to
peek() with the same arguments will return the same results.  This function
requires OpenSSL 0.9.6a or later to work.

=end original

この関数は B<sysread> と全く同じ書き方をします。
そしてほとんど同じ仕事を行います。
しかし連続して同じ引数で peek() を呼び出すと同じ結果が返るように、
読み込み位置を進めません。
この関数が機能するためには、OpenSSL 0.9.6a 以降が必要です。

=item B<pending()>

=begin original

This function gives you the number of bytes available without reading from the
underlying socket object. This function is essential if you work with event
loops, please see the section about polling SSL sockets.

=end original

この関数は、基礎となるソケットオブジェクトから読み取ることなく使用可能なバイト数を提供します。
この関数は、イベントループを操作する場合に不可欠です。
SSLソケットのポーリングに関するセクションを参照してください。
(TBR)

=item B<get_fingerprint([algo])>

=begin original

This methods returns the fingerprint of the peer certificate in the form
C<algo$digest_hex>, where C<algo> is the used algorithm, default 'sha256'.

=end original

このメソッドは、ピア証明書のフィンガープリントをC<algo$digest_hex>の形式で返します。
ここで、C<algo>は使用されたアルゴリズムで、デフォルトは「sha256」です。
(TBR)

=item B<get_fingerprint_bin([algo])>

=begin original

This methods returns the binary fingerprint of the peer certificate by using the
algorithm C<algo>, default 'sha256'.

=end original

このメソッドは、アルゴリズムC<algo>,default'sha256'を使用して、ピア証明書のバイナリフィンガープリントを返します。
(TBR)

=item B<get_cipher()>

=begin original

Returns the string form of the cipher that the IO::Socket::SSL object is using.

=end original

IO::Socket::SSL が使っている暗号を文字列の形で返します。

=item B<get_sslversion()>

=begin original

Returns the string representation of the SSL version of an established
connection.

=end original

確立された接続のSSLバージョンの文字列表現を返します。
(TBR)

=item B<get_sslversion_int()>

=begin original

Returns the integer representation of the SSL version of an established
connection.

=end original

確立された接続のSSLバージョンの整数表現を返します。
(TBR)

=item B<dump_peer_certificate()>

=begin original

Returns a parsable string with select fields from the peer SSL certificate.
This method directly returns the result of the dump_peer_certificate() method of
Net::SSLeay.

=end original

相手の SSL 証明書から選択フィールドが入った解析可能な文字列を返します。
このメソッドは Net::SSLeay の dump_peer_certificate() メソッドの結果を直接、
返します。

=item B<peer_certificate($field;[$refresh])>

=begin original

If a peer certificate exists, this function can retrieve values from it.
If no field is given the internal representation of certificate from Net::SSLeay
is returned.
If refresh is true it will not used a cached version, but check again in case
the certificate of the connection has changed due to renegotiation.

=end original

相手の証明書があれば、この関数はそれから値を取り出します。
フィールドが指定されなかった場合、 Net::SSLeay からの証明書の
内部表現が返されます。
refresh が真なら、キャッシュ版は使いませんが、
接続の証明書が再ネゴシエーションのために変更された場合は再びチェックします。

=begin original

The following fields can be queried:

=end original

以下のフィールドを問い合わせることができます:

=over 8

=item authority (alias issuer)

=begin original

The certificate authority which signed the certificate.

=end original

証明書に署名している認証局。

=item owner (alias subject)

=begin original

The owner of the certificate.

=end original

証明書の発行者。

=item commonName (alias cn) - only for Net::SSLeay version >=1.30

=begin original

The common name, usually the server name for SSL certificates.

=end original

一般名; 通常は SSL 証明書のサーバ名。

=item subjectAltNames - only for Net::SSLeay version >=1.33

=begin original

Alternative names for the subject, usually different names for the same
server, like example.org, example.com, *.example.com.

=end original

サブジェクトの代替名。
通常は、example.org, example.com, *.example.com など、同じサーバに対して
異なる名前です。

=begin original

It returns a list of (typ,value) with typ GEN_DNS, GEN_IPADD etc (these
constants are exported from IO::Socket::SSL).
See Net::SSLeay::X509_get_subjectAltNames.

=end original

typ GEN_DNS, GEN_IPADD などを含む(typ、value)のリストを返します
(これらの定数は IO::Socket::SSL からエクスポートされます)。
Net::SSLeay::X509_get_subjectAltNames を参照してください。

=back

=item B<peer_certificates>

=begin original

This returns all the certificates send by the peer, e.g. first the peers own
certificate and then the rest of the chain. You might use B<CERT_asHash> from
L<IO::Socket::SSL::Utils> to inspect each of the certificates.

=end original

これは、ピアによって送信されたすべての証明書を返します。
たとえば、最初にピアが証明書を所有し、次にチェーンの残りの部分を所有します。
L<IO::Socket::SSL::Utils>のB<CERT_asHash>を使用して、各証明書を検査できます。
(TBR)

=begin original

This function depends on a version of Net::SSLeay >= 1.58 .

=end original

この関数は、Net::SSLeay>=1.58のバージョンに依存します。
(TBR)

=item B<get_servername>

=begin original

This gives the name requested by the client if Server Name Indication
(SNI) was used.

=end original

これは、Server Name Indication(SNI)が使用された場合に、クライアントによって要求された名前を提供します。
(TBR)

=item B<verify_hostname($hostname,$scheme,$publicsuffix)>

=begin original

This verifies the given hostname against the peer certificate using the
given scheme. Hostname is usually what you specify within the PeerAddr.
See the C<SSL_verifycn_publicsuffix> parameter for an explanation of suffix
checking and for the possible values.

=end original

これは、指定されたスキームを使用して、ピア証明書に対して
指定されたホスト名を検証します。
ホスト名は通常、PeerAddr 内で指定するものです。
接頭辞チェックと取りうる値に関する説明については
C<SSL_verifycn_publicsuffix> 引数を参照してください。

=begin original

Verification of hostname against a certificate is different between various
applications and RFCs. Some scheme allow wildcards for hostnames, some only
in subjectAltNames, and even their different wildcard schemes are possible.
RFC 6125 provides a good overview.

=end original

証明書に対するホスト名の検証は、さまざまなアプリケーションおよび
RFC 間で異なります。
スキームによっては、ホスト名にワイルドカードを使用できるものもあれば、
subjectAltNames にのみ使用できるものもあります;
また、異なるワイルドカードスキームも可能です。
RFC 6125 はよい外観を提供します。

=begin original

To ease the verification the following schemes are predefined (both protocol
name and rfcXXXX name can be used):

=end original

検証を容易にするために、次のスキームが事前定義されています
(プロトコル名と rfcXXXX 名の両方が使えます):

=over 8

=item rfc2818, xmpp (rfc3920), ftp (rfc4217)

=begin original

Extended wildcards in subjectAltNames and common name are possible, e.g.
*.example.org or even www*.example.org. The common
name will be only checked if no DNS names are given in subjectAltNames.

=end original

subjectAltNames には、*.example.org や www*.example.org などの
拡張ワイルドカードと共通名を使えます。
共通名は、subjectAltNames に DNS 名が指定されていない場合にのみ
チェックされます。

=item http (alias www)

=begin original

While name checking is defined in rfc2818 the current browsers usually accept
also an IP address (w/o wildcards) within the common name as long as no
subjectAltNames are defined. Thus this is rfc2818 extended with this feature.

=end original

名前チェックはrfc2818で定義されていますが、現在のブラウザは通常、subjectAltNamesが定義されていない限り、共通名の中にIPアドレス(ワイルドカードなし)も受け入れます。
したがって、これはrfc2818がこの機能で拡張されています。
(TBR)

=item smtp (rfc2595), imap, pop3, acap (rfc4642), netconf (rfc5538), syslog (rfc5425), snmp (rfc5953)

=begin original

Simple wildcards in subjectAltNames are possible, e.g. *.example.org matches
www.example.org but not lala.www.example.org. If nothing from subjectAltNames
match it checks against the common name, where wildcards are also allowed to
match the full leftmost label.

=end original

subjectAltNames には単純なワイルドカードを使えます;
たとえば、*.example.org は www.example.org と一致しますが、
lala.www.example.org とは一致しません。
subjectAltNames から何も一致しない場合は、共通名と照合されます;
完全な左端ラベルとのマッチングにワイルドカードも使えます。

=item ldap (rfc4513)

=begin original

Simple wildcards are allowed in subjectAltNames, but not in common name.
Common name will be checked even if subjectAltNames exist.

=end original

subjectAltNamesには単純なワイルドカードを使用できますが、共通名には使用できません。
subjectAltNamesが存在する場合でも、共通名がチェックされます。
(TBR)

=item sip (rfc5922)

=begin original

No wildcards are allowed and common name is checked even if subjectAltNames
exist.

=end original

ワイルドカードは使用できません。
subjectAltNamesが存在する場合でも、共通名がチェックされます。
(TBR)

=item gist (rfc5971)

=begin original

Simple wildcards are allowed in subjectAltNames and common name, but common name
will only be checked if their are no DNS names in subjectAltNames.

=end original

単純なワイルドカードはsubjectAltNamesとcommon nameで許可されますが、common nameはsubjectAltNamesにDNS名がない場合にのみチェックされます。
(TBR)

=item default

=begin original

This is a superset of all the rules and is automatically used if no scheme is
given but a hostname (instead of IP) is known.
Extended wildcards are allowed in subjectAltNames and common name and common
name is checked always.

=end original

これはすべてのルールのスーパーセットであり、スキームが指定されていないが(IPの代わりに)ホスト名がわかっている場合に自動的に使用されます。
拡張ワイルドカードはsubjectAltNamesで許可され、共通名と共通名は常にチェックされます。
(TBR)

=item none

=begin original

No verification will be done.
Actually is does not make any sense to call verify_hostname in this case.

=end original

検証は行われません。
実際には、この場合に verify_hostname を呼び出しても意味がありません。

=back

=begin original

The scheme can be given either by specifying the name for one of the above
predefined schemes, or by using a hash which can have the following keys and
values:

=end original

スキームを指定するには、上記の定義済みスキームのいずれかの名前を指定するか、
次のキーと値を持つハッシュを使います。

=over 8

=item check_cn:  0|'always'|'when_only'

=begin original

Determines if the common name gets checked. If 'always' it will always be
checked (like in ldap), if 'when_only' it will only be checked if no names are
given in subjectAltNames (like in http), for any other values the common name
will not be checked.

=end original

共通名がチェックされるかどうかを決定します。
'always' の場合は常にチェックされ(ldap の場合と同様)、
'when_only' の場合は subjectAltNames に名前が指定されていない場合にのみ
チェックされ(http の場合と同様)、その他の値の場合は共通名は
チェックされません。

=item wildcards_in_alt: 0|'full_label'|'anywhere'

=begin original

Determines if and where wildcards in subjectAltNames are possible. If
'full_label' only cases like *.example.org will be possible (like in ldap), for
'anywhere' www*.example.org is possible too (like http), dangerous things like
but www.*.org or even '*' will not be allowed.
For compatibility with older versions 'leftmost' can be given instead of
'full_label'.

=end original

subjectAltNames でワイルドカードを使用できるかどうか、
および使用できる場合はどこで使用できるかを決定します。
'leftmost' の場合は *.example.org のようなケースのみが可能で
(ldap の場合のように)、'anywhere' の場合は www*.example.org も可能で
(http の場合のように)、www.*.org や '*' のような危険なものは許可されません。
古いバージョンとの互換性のために、'full_label' の代わりに
'leftmost' を指定することもできます。

=item wildcards_in_cn: 0|'full_label'|'anywhere'

=begin original

Similar to wildcards_in_alt, but checks the common name. There is no predefined
scheme which allows wildcards in common names.

=end original

wildcards_in_alt と似ていますが、共通名をチェックします。
共通名にワイルドカードを使用できる事前定義されたスキームはありません。

=item ip_in_cn: 0|1|4|6

=begin original

Determines if an IP address is allowed in the common name (no wildcards are
allowed). If set to 4 or 6 it only allows IPv4 or IPv6 addresses, any other
true value allows both.

=end original

共通名にIPアドレスを使用できるかどうかを決定します(ワイルドカードは使用できません)。
4または6に設定すると、IPv4アドレスまたはIPv6アドレスのみが使用可能になり、その他のtrue値では両方が使用可能になります。
(TBR)

=item callback: \&coderef

=begin original

If you give a subroutine for verification it will be called with the arguments
($hostname,$commonName,@subjectAltNames), where hostname is the name given for
verification, commonName is the result from peer_certificate('cn') and
subjectAltNames is the result from peer_certificate('subjectAltNames').

=end original

検証用のサブルーチンを指定すると、
引数 ($hostname, $commonName, @subjectAltNames) を指定して呼び出されます;
ここで、hostname は検証用に指定された名前、
commonName は peer_certificate('cn') の結果、
subjectAltNames は peer_certificate('subjectAltNames') の結果です。

=begin original

All other arguments for the verification scheme will be ignored in this case.

=end original

この場合、検証スキームの他のすべての引数は無視されます。

=back

=item B<next_proto_negotiated()>

=begin original

This method returns the name of negotiated protocol - e.g. 'http/1.1'. It works
for both client and server side of SSL connection.

=end original

このメソッドは、ネゴシエートされたプロトコルの名前 ('http/1.1' など) を
返します。
SSL 接続のクライアント側とサーバー側の両方で機能します。

=begin original

NPN support is available with Net::SSLeay 1.46+ and openssl-1.0.1+.
To check support you might call C<IO::Socket::SSL->can_npn()>.

=end original

NPN のサポートは、Net::SSLeay 1.46+ と openssl-1.0.1+ で利用できます。
サポートをチェックするためには、C<IO::Socket::SSL->can_npn()> を
呼び出せます。

=item B<errstr()>

=begin original

Returns the last error (in string form) that occurred.	If you do not have a
real object to perform this method on, call IO::Socket::SSL::errstr() instead.

=end original

発生した最後のエラーを(文字列形式で)返します。
このメソッドを実行するための
本物のオブジェクトを持っていなければ、代わりに IO::Socket::SSL::errstr() を
呼び出してください。

=begin original

For read and write errors on non-blocking sockets, this method may include the
string C<SSL wants a read first!> or C<SSL wants a write first!> meaning that
the other side is expecting to read from or write to the socket and wants to be
satisfied before you get to do anything. But with version 0.98 you are better
comparing the global exported variable $SSL_ERROR against the exported symbols
SSL_WANT_READ and SSL_WANT_WRITE.

=end original

ブロックしていないソケットの読み込みや書込みに、このメソッドは、
もう一方の側がソケットからの読み込みや書き込みを待っていて、あなたが
何かする前に満足させて欲しいと思っていることを意味する、
C<SSL wants a read first!> あるいは C<SSL wants a write first!> を
文字列に入れるかもしれません。
しかしバージョン 0.98 からは、グローバルにエクスポートされた変数
$SSL_ERROR を、エクスポートされたシンボル SSL_WANT_READ および
SSL_WANT_WRITE と比較した方がよいです。

=item B<opened()>

=begin original

This returns false if the socket could not be opened, 1 if the socket could be
opened and the SSL handshake was successful done and -1 if the underlying
IO::Handle is open, but the SSL handshake failed.

=end original

ソケットを開くことができなかった場合は偽、
ソケットを開くことができて SSL ハンドシェイクが成功した場合は 1、
基礎となる IO::Handle は開いているが SSL ハンドシェイクが失敗した場合は
-1 を返します。

=item B<< IO::Socket::SSL->start_SSL($socket, ... ) >>

=begin original

This will convert a glob reference or a socket that you provide to an
IO::Socket::SSL object.	 You may also pass parameters to specify context or
connection options as with a call to new().  If you are using this function on
an accept()ed socket, you must set the parameter "SSL_server" to 1, i.e.
IO::Socket::SSL->start_SSL($socket, SSL_server => 1).  If you have a class that
inherits from IO::Socket::SSL and you want the $socket to be blessed into your
own class instead, use MyClass->start_SSL($socket) to achieve the desired
effect.

=end original

これは、あなたが与えた glob リファレンスやソケットを
IO::Socket::SSL オブジェクトに変換します。
コンテキストや new() を呼び出すときのような接続オプションを指定するため、
パラメータを渡すこともできます。
もしこの関数を accept() されたソケットに使うのであれば、
パラメータ "SSL_server" を 1 に設定しなければなりません。
つまり IO::Socket::SSL->start_SSL($socket, SSL_server => 1) です。
IO::Socket::SSL から継承したクラスを持っていて、
代わりに自分自身のクラスで $socket を bless したいときは、
望みの効果を得るために MyClass->start_SSL($socket) を使ってください。

=begin original

Note that if start_SSL() fails in SSL negotiation, $socket will remain blessed
in its original class.	 For non-blocking sockets you better just upgrade the
socket to IO::Socket::SSL and call accept_SSL or connect_SSL and the upgraded
object. To just upgrade the socket set B<SSL_startHandshake> explicitly to 0. If
you call start_SSL w/o this parameter it will revert to blocking behavior for
accept_SSL and connect_SSL.

=end original

start_SSL() が SSL ネゴシエーションに失敗した場合、
$socket は元のクラスで bless されたままになることに注意してください。
非ブロッキングソケットの場合は、ソケットを IO::Socket::SSL に
アップグレードし、accept_SSL または connect_SSL と
アップグレードされたオブジェクトを呼び出します。
ソケットをアップグレードするには、B<SSL_startHandshake> を
明示的に 0 に設定します。
このパラメータを使用せずに start_SSL を呼び出すと、
accept_SSL と connect_SSL のブロッキング動作に戻ります。

=begin original

If given the parameter "Timeout" it will stop if after the timeout no SSL
connection was established. This parameter is only used for blocking sockets, if
it is not given the default Timeout from the underlying IO::Socket will be
used.

=end original

パラメータ "Timeout" を指定すると、タイムアウト後に
SSL 接続が確立されなかった場合に停止します。
このパラメータは、ソケットのブロックにのみ使われます;
このパラメータが指定されていない場合は、
基礎となる IO::Socket からのデフォルトの Timeout が使用されます。

=item B<stop_SSL(...)>

=begin original

This is the opposite of start_SSL(), connect_SSL() and accept_SSL(), e.g. it
will shutdown the SSL connection and return to the class before start_SSL(). It
gets the same arguments as close(), in fact close() calls stop_SSL() (but
without downgrading the class).

=end original

これは start_SSL(), connect_SSL(), accept_SSL() とは逆です;
例えば、start_SSL() の前に SSL 接続をシャットダウンしてクラスに戻ります。
close() と同じ引数を受け取ります;
実際に close() は stop_SSL() を呼び出します
(ただし、クラスをダウングレードすることはありません)。

=begin original

Will return true if it succeeded and undef if failed. This might be the case for
non-blocking sockets. In this case $! is set to EAGAIN and the ssl error to
SSL_WANT_READ or SSL_WANT_WRITE. In this case the call should be retried again
with the same arguments once the socket is ready.

=end original

成功した場合は真を返し、失敗した場合は undef を返します。
これは、非ブロッキングソケットの場合に当てはまります。
この場合、$! は EAGAIN に設定され、ssl エラーは SSL_WANT_READ または
SSL_WANT_WRITE に設定されます。
この場合、ソケットの準備ができたら、同じ引数で呼び出しを
再試行する必要があります。

=begin original

For calling from C<stop_SSL> C<SSL_fast_shutdown> default to false, e.g. it
waits for the close_notify of the peer. This is necesarry in case you want to
downgrade the socket and continue to use it as a plain socket.

=end original

C<stop_SSL>からの呼び出しの場合、C<SSL_fast_shutdown>はデフォルトでfalseに設定されます。
たとえば、ピアのclose_notifyを待機します。
これは、ソケットをダウングレードして、それをプレーンソケットとして使い続ける場合に必要です。
(TBR)

=begin original

After stop_SSL the socket can again be used to exchange plain data.

=end original

stop_SSLの後、ソケットは再びプレーンデータの交換に使用できます。
(TBR)

=item B<connect_SSL>, B<accept_SSL>

=begin original

These functions should be used to do the relevant handshake, if the socket got
created with C<new> or upgraded with C<start_SSL> and C<SSL_startHandshake> was
set to false.
They will return undef until the handshake succeeded or an error got thrown.
As long as the function returns undef and $! is set to EAGAIN one could retry
the call after the socket got readable (SSL_WANT_READ) or writeable
(SSL_WANT_WRITE).

=end original

これらの関数は、ソケットがC<new>で作成された場合、またはC<start_SSL>でアップグレードされ、C<SSL_startHandshake>がfalseに設定されている場合に、関連するハンドシェイクを実行するために使用する必要があります。
ハンドシェイクが成功するか、エラーがスローされるまで、これらの関数はundefを返します。
関数がundefを返し、$!がEAGAINに設定されている限り、ソケットが読み取り可能(SSL_WANT_READ)または書き込み可能(SSL_WANT_WRITE)になった後に呼び出しを再試行できます。
(TBR)

=item B<ocsp_resolver>

=begin original

This will create an OCSP resolver object, which can be used to create OCSP
requests for the certificates of the SSL connection. Which certificates are
verified depends on the setting of C<SSL_ocsp_mode>: by default only the leaf
certificate will be checked, but with SSL_OCSP_FULL_CHAIN all chain
certificates will be checked.

=end original

これにより、SSL接続の証明書に対するOCSPリクエストの作成に使用できるOCSPリゾルバオブジェクトが作成されます。
どの証明書が検証されるかは、C<SSL_ocsp_mode>の設定によって異なります。
デフォルトではリーフ証明書のみがチェックされますが、SSL_OCSP_FULL_CHAINを使用すると、すべてのチェーン証明書がチェックされます。
(TBR)

=begin original

Because to create an OCSP request the certificate and its issuer certificate
need to be known it is not possible to check certificates when the trust chain
is incomplete or if the certificate is self-signed.

=end original

OCSP要求を作成するには、証明書とその発行者証明書が既知である必要があるため、トラストチェーンが不完全な場合、または証明書が自己署名されている場合は、証明書をチェックできません。
(TBR)

=begin original

The OCSP resolver gets created by calling C<$ssl->ocsp_resolver> and provides
the following methods:

=end original

OCSPリゾルバは、C<$ssl->ocsp_resolver>を呼び出すことによって作成され、次のメソッドを提供します。
(TBR)

=over 8

=item hard_error

=begin original

This returns the hard error when checking the OCSP response.
Hard errors are certificate revocations. With the C<SSL_ocsp_mode> of
SSL_OCSP_FAIL_HARD any soft error (e.g. failures to get signed information
about the certificates) will be considered a hard error too.

=end original

OCSPレスポンスのチェック時にハードエラーを返します。
ハードエラーは、証明書の失効です。
SSL_OCSP_FAIL_HARDのC<SSL_ocsp_mode>を使用すると、ソフトエラー(証明書に関する署名付き情報の取得の失敗など)もハードエラーとみなされます。
(TBR)

=begin original

The OCSP resolving will stop on the first hard error.

=end original

OCSPの解決は、最初のハードエラーで停止します。
(TBR)

=begin original

The method will return undef as long as no hard errors occured and still
requests to be resolved. If all requests got resolved and no hard errors
occured the method will return C<''>.

=end original

ハードエラーが発生せず、解決すべき要求がある限り、メソッドはundefを返します。
すべての要求が解決され、ハードエラーが発生しなかった場合、メソッドはC<''>を返します。
(TBR)

=item soft_error

=begin original

This returns the soft error(s) which occured when asking the OCSP responders.

=end original

OCSPレスポンダへの問い合わせ時に発生したソフトエラーを返します。
(TBR)

=item requests

=begin original

This will return a hash consisting of C<(url,request)>-tuples, e.g. which
contain the OCSP request string and the URL where it should be sent too. The
usual way to send such a request is as HTTP POST request with an content-type
of C<application/ocsp-request> or as a GET request with the base64 and
url-encoded request is added to the path of the URL.

=end original

これは、C<(url,request)>タプルで構成されるハッシュを返します。
たとえば、OCSP要求文字列と、それが送信されるURLが含まれます。
このような要求を送信する通常の方法は、C<application/ocsp-request>のcontent-typeを持つHTTP POST要求、またはbase64とURLエンコードされた要求がURLのパスに追加されたGET要求です。
(TBR)

=begin original

After you've handled all these requests and added the response with
C<add_response> you should better call this method again to make sure, that no
more requests are outstanding. IO::Socket::SSL will combine multiple OCSP
requests for the same server inside a single request, but some server don't
give an response to all these requests, so that one has to ask again with the
remaining requests.

=end original

これらの要求をすべて処理し、C<add_response>で応答を追加したら、このメソッドを再度呼び出して、未処理の要求がないことを確認する必要があります。
IO::Socket::SSLは、1つの要求内で同じサーバに対する複数のOCSP要求を結合しますが、一部のサーバはこれらの要求すべてに応答しないため、残りの要求に対して再度要求する必要があります。
(TBR)

=item add_response($uri,$response)

=begin original

This method takes the HTTP body of the response which got received when sending
the OCSP request to C<$uri>. If no response was received or an error occured
one should either retry or consider C<$response> as empty which will trigger a
soft error.

=end original

このメソッドは、OCSP要求をC<$uri>に送信したときに受信した応答のHTTP本文を取得します。
応答が受信されなかった場合、またはエラーが発生した場合は、再試行するか、C<$response>が空であると見なす必要があります。
これにより、ソフトエラーが発生します。
(TBR)

=begin original

The method returns the current value of C<hard_error>, e.g. a defined value
when no more requests need to be done.

=end original

このメソッドは、C<hard_error>の現在の値を返します。
たとえば、要求を実行する必要がなくなったときに定義された値を返します。
(TBR)

=item resolve_blocking(%args)

=begin original

This combines C<requests> and C<add_response> which L<HTTP::Tiny> to do all
necessary requests in a blocking way. C<%args> will be given to L<HTTP::Tiny>
so that you can put proxy settings etc here. L<HTTP::Tiny> will be called with
C<verify_SSL> of false, because the OCSP responses have their own signatures so
no extra SSL verification is needed.

=end original

これは、C<requests>とC<add_response>を組み合わせたもので、L<HTTP::Tiny>は必要なすべての要求をブロック方式で実行します。
C<%args>はL<HTTP::Tiny>に与えられるので、ここにプロキシ設定などを置くことができます。
L<HTTP::Tiny>はC<verify_SSL>をfalseにして呼び出されます。
これは、OCSP応答には独自の署名があるため、追加のSSL検証は必要ないためです。
(TBR)

=begin original

If you don't want to use blocking requests you need to roll your own user agent
with C<requests> and C<add_response>.

=end original

ブロッキングリクエストを使用したくない場合は、C<requests>とC<add_response>を使用して独自のユーザーエージェントを作成する必要があります。
(TBR)

=back

=item B<< IO::Socket::SSL->new_from_fd($fd, [mode], %sslargs) >>

=begin original

This will convert a socket identified via a file descriptor into an SSL socket.
Note that the argument list does not include a "MODE" argument; if you supply
one, it will be thoughtfully ignored (for compatibility with IO::Socket::INET).
Instead, a mode of '+<' is assumed, and the file descriptor passed must be able
to handle such I/O because the initial SSL handshake requires bidirectional
communication.

=end original

これは、ファイル記述子を介して識別されるソケットを SSL ソケットに変換します。
引数リストには "MODE" 引数が含まれていないことに注意してください;
これを指定すると、(IO::Socket::INET との互換性のために)慎重に無視されます。
代わりに、'+<' のモードが想定され、最初の SSL ハンドシェイクには双方向通信が
必要であるため、渡されるファイル記述子はそのような I/O を処理できる必要があります。

=begin original

Internally the given $fd will be upgraded to a socket object using the
C<new_from_fd> method of the super class (L<IO::Socket::INET> or similar) and
then C<start_SSL> will be called using the given C<%sslargs>.
If C<$fd> is already an IO::Socket object you should better call C<start_SSL>
directly.

=end original

内部的には、指定された$fdは、スーパークラス(L<IO::Socket::INET>など)のC<new_from_fd>メソッドを使用してソケットオブジェクトにアップグレードされ、指定されたC<%sslargs>を使用してC<start_SSL>が呼び出されます。
C<$fd>がすでにIO::Socketオブジェクトである場合は、C<start_SSL>を直接呼び出す必要があります。
(TBR)

=item B<IO::Socket::SSL::default_ca([ path|dir| SSL_ca_file => ..., SSL_ca_path => ... ])>

=begin original

Determines or sets the default CA path.
If existing path or dir or a hash is given it will set the default CA path to
this value and never try to detect it automatically.
If C<undef> is given it will forget any stored defaults and continue with
detection of system defaults.
If no arguments are given it will start detection of system defaults, unless it
has already stored user-set or previously detected values.

=end original

デフォルトのCAパスを決定または設定します。
既存のパス、ディレクトリ、またはハッシュが指定されている場合、デフォルトのCAパスはこの値に設定され、自動的に検出されることはありません。
C<undef>が指定されている場合、保存されているデフォルトはすべて無視され、システムデフォルトの検出が続行されます。
引数が指定されていない場合、ユーザー設定の値または以前に検出された値がすでに保存されていない限り、システムデフォルトの検出が開始されます。
(TBR)

=begin original

The detection of system defaults works similar to OpenSSL, e.g. it will check
the directory specified in environment variable SSL_CERT_DIR or the path
OPENSSLDIR/certs (SSLCERTS: on VMS) and the file specified in environment
variable SSL_CERT_FILE or the path OPENSSLDIR/cert.pem (SSLCERTS:cert.pem on
VMS). Contrary to OpenSSL it will check if the SSL_ca_path contains PEM files
with the hash as file name and if the SSL_ca_file looks like PEM.
If no usable system default can be found it will try to load and use
L<Mozilla::CA> and if not available give up detection.
The result of the detection will be saved to speed up future calls.

=end original

システムデフォルトの検出はOpenSSLと同様に機能します。
たとえば、環境変数SSL_CERT_DIRで指定されたディレクトリまたはパスOPENSSLDIR/certs(VMSではSSLCERTS:)、および環境変数SSL_CERT_FILEで指定されたファイルまたはパスOPENSSLDIR/cert.pem(VMSではSSLCERTS:cert.pem)をチェックします。
OpenSSLとは異なり、SSL_ca_pathにファイル名としてハッシュを持つPEMファイルが含まれているかどうか、およびSSL_ca_fileがPEMに似ているかどうかをチェックします。
使用可能なシステムデフォルトが見つからない場合は、L<Mozilla::CA>をロードして使用しようとしますが、使用できない場合は検出を中止します。
検出の結果は、今後の呼び出しを高速化するために保存されます。
(TBR)

=begin original

The function returns the saved default CA as hash with SSL_ca_file and
SSL_ca_path.

=end original

この関数は、保存されたデフォルトCAをSSL_ca_fileおよびSSL_ca_pathを持つハッシュとして戻します。
(TBR)

=item B<IO::Socket::SSL::set_default_context(...)>

=begin original

You may use this to make IO::Socket::SSL automatically re-use a given context
(unless specifically overridden in a call to new()).
It accepts one argument, which should be either an IO::Socket::SSL object or an
IO::Socket::SSL::SSL_Context object.
See the SSL_reuse_ctx option of new() for more details.
Note that this sets the default context globally, so use with caution (esp. in
mod_perl scripts).

=end original

これを使用して、IO::Socket::SSL が特定のコンテキストを自動的に
再利用するようにすることができます(new() の呼び出しで特に上書きされない限り)。
これは一つの引数を受け入れます;
この引数は、IO::Socket::SSL オブジェクトまたは
IO::Socket::SSL::SSL_Context オブジェクトのいずれかである必要があります。
詳細については、new() の SSL_reuse_ctx オプションを参照してください。
これによりデフォルトのコンテキストがグローバルに設定されるため、
注意して使用してください(特に mod_perl スクリプトで)。

=item B<IO::Socket::SSL::set_default_session_cache(...)>

=begin original

You may use this to make IO::Socket::SSL automatically re-use a given session
cache (unless specifically overridden in a call to new()).
It accepts one argument, which should be an IO::Socket::SSL::Session_Cache
object or similar (e.g something which implements get_session and add_session
like IO::Socket::SSL::Session_Cache does).
See the SSL_session_cache option of new() for more details.
Note that this sets the default cache globally, so use with caution.

=end original

これを使用して、IO::Socket::SSL が指定されたセッションキャッシュを
自動的に再利用するようにすることができます
(new() の呼び出しで特に上書きされない限り)。
これは一つの引数を受け入れますが、これは
IO::Socket::SSL::Session_Cache オブジェクトまたは同様のもの
(例えば、IO::Socket::SSL::Session_Cache のように get_session と
add_session を実装するもの)である必要があります。
詳細については、new() の SSL_session_cache オプションを参照してください。
これによりデフォルトのキャッシュがグローバルに設定されるため、
注意して使用してください。

=item B<IO::Socket::SSL::set_defaults(%args)>

=begin original

With this function one can set defaults for all SSL_* parameter used for
creation of the context, like the SSL_verify* parameter. Any SSL_* parameter can
be given or the following short versions:

=end original

この関数を使うと、SSL_verify* パラメータのように、
コンテキストの作成に使用されるすべての SSL_* パラメータのデフォルトを
設定できます。
任意の SSL_* パラメータが指定でき、次の短縮版も使えます。

=over 8

=item mode - SSL_verify_mode

=item callback - SSL_verify_callback

=item scheme - SSL_verifycn_scheme

=item name - SSL_verifycn_name

=back

=item B<IO::Socket::SSL::set_client_defaults(%args)>

=begin original

Similar to C<set_defaults>, but only sets the defaults for client mode.

=end original

Cの<set_defaults>と似ていますが、クライアントモードのデフォルトを設定するだけです。
(TBR)

=item B<IO::Socket::SSL::set_server_defaults(%args)>

=begin original

Similar to C<set_defaults>, but only sets the defaults for server mode.

=end original

Cの<set_defaults>と似ていますが、サーバモードのデフォルトを設定するだけです。
(TBR)

=item B<IO::Socket::SSL::set_args_filter_hack(\&code|'use_defaults')>

=begin original

Sometimes one has to use code which uses unwanted or invalid arguments for SSL,
typically disabling SSL verification or setting wrong ciphers or SSL versions.
With this hack it is possible to override these settings and restore sanity.
Example:

=end original

場合によっては、SSLに対して不要または無効な引数を使用するコードを使用する必要があります。
通常は、SSL検証を無効にしたり、間違った暗号やSSLバージョンを設定したりします。
このハックを使用すると、これらの設定を上書きして健全性を回復できます。
例:
(TBR)

    IO::Socket::SSL::set_args_filter_hack( sub {
	my ($is_server,$args) = @_;
	if ( ! $is_server ) {
	    # client settings - enable verification with default CA
	    # and fallback hostname verification etc
	    delete @{$args}{qw(
		SSL_verify_mode
		SSL_ca_file
		SSL_ca_path
		SSL_verifycn_scheme
		SSL_version
	    )};
	    # and add some fingerprints for known certs which are signed by
	    # unknown CAs or are self-signed
	    $args->{SSL_fingerprint} = ...
	}
    });

=begin original

With the short setting C<set_args_filter_hack('use_defaults')> it will prefer
the default settings in all cases. These default settings can be modified with
C<set_defaults>, C<set_client_defaults> and C<set_server_defaults>.

=end original

短い設定C<set_args_filter_hack('use_defaults')>を使用すると、すべての場合にデフォルト設定が優先されます。
これらのデフォルト設定は、C<set_defaults>、C<set_client_defaults>、およびC<set_server_defaults>で変更できます。
(TBR)

=back

=begin original

The following methods are unsupported (not to mention futile!) and
IO::Socket::SSL will emit a large CROAK() if you are silly enough to use them:

=end original

以下のメソッドは対応していません(役に立たないと
いっているわけではありません!)
そしてあなたがそれらを使うほどのオバカさんであれば、IO::Socket::SSL は
巨大な CROAK() を吐き出すことになります。

=over 4

=item truncate

=item stat

=item ungetc

=item setbuf

=item setvbuf

=item fdopen

=item send/recv

=begin original

Note that send() and recv() cannot be reliably trapped by a tied filehandle
(such as that used by IO::Socket::SSL) and so may send unencrypted data over the
socket.	 Object-oriented calls to these functions will fail, telling you to use
the print/printf/syswrite and read/sysread families instead.

=end original

send() と recv() は、tie されたファイルハンドル
(IO::Socket::SSL で使用されるものなど)では確実にトラップできないため、
暗号化されていないデータをソケット経由で送信する可能性があることに
注意してください。
これらの関数へのオブジェクト指向の呼び出しは失敗し、
代わりに print/printf/syswrite および read/sysread ファミリを
使用するように指示されます。

=back

=head1 DEPRECATIONS

(廃止予定)

=begin original

The following functions are deprecated and are only retained for compatibility:

=end original

以下の関数は廃止予定(deprecate)になり、互換性のためだけに維持されています:

=over 2

=item context_init()

=begin original

use the SSL_reuse_ctx option if you want to re-use a context

=end original

コンテキストを再利用したければ、SSL_reuse_ctx オプションを使ってください

=item socketToSSL() and socket_to_SSL()

=begin original

use IO::Socket::SSL->start_SSL() instead

=end original

代わりに IO::Socket::SSL->start_SSL() を使ってください

=item kill_socket()

=begin original

use close() instead

=end original

代わりに close() を使ってください

=item get_peer_certificate()

=begin original

use the peer_certificate() function instead.
Used to return X509_Certificate with methods subject_name and issuer_name.
Now simply returns $self which has these methods (although deprecated).

=end original

代わりに peer_certificate() 関数を使ってください。
X509_Certificateをメソッドsubject_nameおよびissuer_nameとともに返すために使われていました。
現在では、これらのメソッドを持つ$selfを返すだけです(ただし、これは廃止予定です)。

=item issuer_name()

=begin original

use peer_certificate( 'issuer' ) instead

=end original

代わりに peer_certificate( 'issuer' ) を使ってください

=item subject_name()

=begin original

use peer_certificate( 'subject' ) instead

=end original

代わりに peer_certificate( 'subject' ) を使ってください

=back

=head1 EXAMPLES

=begin original

See the 'example' directory, the tests in 't' and also the tools in 'util'.

=end original

'example'ディレクトリ、't' にあるテストと 'util' にあるツールをご覧ください。

=head1 BUGS

=begin original

If you use IO::Socket::SSL together with threads you should load it (e.g. use or
require) inside the main thread before creating any other threads which use it.
This way it is much faster because it will be initialized only once. Also there
are reports that it might crash the other way.

=end original

IO::Socket::SSLをスレッドと一緒に使用する場合は、それを使用する他のスレッドを作成する前に、メインスレッド内にロードする必要があります(例:useまたはrequire)。
このようにすると、一度しか初期化されないため、はるかに高速になります。
また、逆にクラッシュする可能性があるという報告もあります。
(TBR)

=begin original

Creating an IO::Socket::SSL object in one thread and closing it in another
thread will not work.

=end original

あるスレッドで IO::Socket::SSL オブジェクトを作成し、別のスレッドで
それを閉じることはできません。

=begin original

IO::Socket::SSL does not work together with Storable::fd_retrieve/fd_store.
See BUGS file for more information and how to work around the problem.

=end original

IO::Socket::SSLは、Storable::fd_retrieve/fd_store と連携して動作しません。
詳細および問題の回避方法については、BUGS ファイルを参照してください。

=begin original

Non-blocking and timeouts (which are based on non-blocking) are not
supported on Win32, because the underlying IO::Socket::INET does not support
non-blocking on this platform.

=end original

Win32 では、基礎となる IO::Socket::INET が非ブロッキングに対応していないため、
非ブロッキングと(非ブロッキングに基づく)タイムアウトは対応していません。

=begin original

If you have a server and it looks like you have a memory leak you might
check the size of your session cache. Default for Net::SSLeay seems to be
20480, see the example for SSL_create_ctx_callback for how to limit it.

=end original

サーバを使用していて、メモリリークが発生しているように見える場合は、
セッションキャッシュのサイズを確認してください。
Net::SSLeay のデフォルトは 20480 のようです。
制限方法については、SSL_create_ctx_callback の例を参照してください。

=head1 SEE ALSO

IO::Socket::INET, IO::Socket::INET6, IO::Socket::IP, Net::SSLeay.

=head1 THANKS

=begin original

Many thanks to all who added patches or reported bugs or helped IO::Socket::SSL
another way. Please keep reporting bugs and help with patches, even if they just
fix the documentation.

=end original

パッチを追加したり、バグを報告したり、IO::Socket::SSLを別の方法で支援してくれたすべての人に深く感謝します。
文書を修正するだけであっても、バグの報告とパッチの支援を続けてください。
(TBR)

=begin original

Special thanks to the team of Net::SSLeay for the good cooperation.

=end original

Net::SSLeayのチームの良好な協力に特に感謝します。
(TBR)

=head1 AUTHORS

=begin original

Steffen Ullrich, <sullr at cpan.org> is the current maintainer.

=end original

Steffen Ullrich, <sullr at cpan.org> は現在のメンテナです。

=begin original

Peter Behroozi, <behrooz at fas.harvard.edu> (Note the lack of an "i" at the end of "behrooz")

=end original

Peter Behroozi, <behrooz at fas.harvard.edu>
("behrooz" の最後の "i" がないことに注意)

=begin original

Marko Asplund, <marko.asplund at kronodoc.fi>, was the original author of IO::Socket::SSL.

=end original

Marko Asplund, <marko.asplund at kronodoc.fi> は
IO::Socket::SSL の元のメンテナです。

=begin original

Patches incorporated from various people, see file Changes.

=end original

様々な人々から組み込まれたパッチについては Changes ファイルを
参照してください。

=head1 COPYRIGHT

=begin original

The original versions of this module are Copyright (C) 1999-2002 Marko Asplund.

=end original

このモジュールの元のバージョンは:
Copyright (C) 1999-2002 Marko Asplund.

=begin original

The rewrite of this module is Copyright (C) 2002-2005 Peter Behroozi.

=end original

このモジュールの書き換えは:
Copyright (C) 2002-2005 Peter Behroozi.

=begin original

Versions 0.98 and newer are Copyright (C) 2006-2014 Steffen Ullrich.

=end original

バージョン0.98以降は、Copyright(C)2006-2014 Steffen Ullrichです。
(TBR)

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=begin meta

Translate: hippo2000
Update: SHIRAKATA Kentaro <argrath@ub32.org> (1.33-)
Status: in progress

=end meta

