=encoding utf8

=head1 NAME

=begin original

Mojolicious::Guides::Tutorial - Get started with Mojolicious

=end original

Mojolicious::Guides::Tutorial - Mojoliciousをはじめよう

=head1 TUTORIAL

(説明)

=begin original

A quick example-driven introduction to the wonders of L<Mojolicious::Lite>.
Almost everything you'll learn here also applies to full L<Mojolicious>
applications.

=end original

L<Mojolicious::Lite>の特徴を簡単なサンプルで紹介していきます。 ここで学んだことは、ほとんどすべてがフルバージョンのL<Mojolicious>アプリケーションにも当てはまります。

=begin original

This is only the first of the L<Mojolicious::Guides>. Other guides delve deeper
into topics like L<growing|Mojolicious::Guides::Growing> a L<Mojolicious::Lite>
prototype into a well-structured L<Mojolicious> application,
L<routing|Mojolicious::Guides::Routing>,
L<rendering|Mojolicious::Guides::Rendering> and more. It is highly encouraged
that readers continue on to the remaining guides after reading this one.

=end original

チュートリアルはL<Mojolicious::Guides>のはじめの章です。その他のガイドでは、各トピックについて深く掘り下げます。たとえば、L<Mojolicious::Lite>のプロトタイプをしっかり構築したL<Mojolicious> アプリケーションに育てるためのL<growing|Mojolicious::Guides::Growing>、またはL<routing|Mojolicious::Guides::Routing>、 L<rendering|Mojolicious::Guides::Rendering>、その他にもたくさんあります。これを読み終わった後は、残りのガイドを読むことををおすすめします。

=head2 Hello World

=begin original

A simple Hello World application can look like this, L<strict>, L<warnings>,
L<utf8> and Perl 5.10 L<features|feature> are automatically enabled and a few
L<functions|Mojolicious::Lite/"FUNCTIONS"> imported, when you use
L<Mojolicious::Lite>, turning your script into a full featured web application.

=end original

かんたんなHello Worldアプリケーションはこのようになります。L<strict>,
L<warnings>,
L<utf8> 、Perl 5.10のL<features|feature> が自動的に有効になり、 L<functions|Mojolicious::Lite/"FUNCTIONS"> がいくつかインポートされます。 L<Mojolicious::Lite>を使うと、あなたのスクリプトは完全な機能を備えたウェブアプリケーションになります。

  #!/usr/bin/env perl
  use Mojolicious::Lite;

  get '/' => sub {
    my $c = shift;
    $c->render(text => 'Hello World!');
  };

  app->start;

=begin original

With L<Mojolicious::Command::Author::generate::lite_app> there is also a helper
command to generate a small example application.

=end original

L<Mojolicious::Command::Author::generate::lite_app> には、小さなアプリケーションサンプルを生成するためのヘルパーコマンドがあります。

  $ mojo generate lite_app myapp.pl

=head2 Commands

(コマンド)

=begin original

Many different L<commands|Mojolicious::Commands/"COMMANDS"> are automatically
available from the command line. CGI and L<PSGI> environments can even be
detected and will usually just work without commands.

=end original

多くのL<commands|Mojolicious::Commands> が自動的にコマンドラインから利用できるようになります。CGIまたはL<PSGI> のどちらの環境であるかは自動的に検知されるため、通常はコマンドで指定しなくても動作します。

  $ ./myapp.pl daemon
  Server available at http://127.0.0.1:3000

  $ ./myapp.pl daemon -l http://*:8080
  Server available at http://127.0.0.1:8080

  $ ./myapp.pl cgi
  ...CGI output...

  $ ./myapp.pl get /
  Hello World!

=begin original

  $ ./myapp.pl
  ...List of available commands (or automatically detected environment)...

=end original

  $ ./myapp.pl
  ...利用可能なコマンドが表示(または自動的に環境が検知される)...

=begin original

A call to L<Mojolicious/"start"> (C<app-E<gt>start>), which starts the command
system, should be the last expression in your application, because its return
value can be significant.

=end original

L<Mojolicious/"start"> (C<app-E<gt>start>)を呼び出すと、コマンドシステムが開始されます。この呼び出しはアプリケーションの最後に置くべきです。というのは、返り値が大きな影響をもつ場合があるからです。

=begin original

  # Use @ARGV to pick a command
  app->start;

=end original

  # @ARGVを使ってコマンドを取得する
  app->start;

=begin original

  # Start the "daemon" command
  app->start('daemon', '-l', 'http://*:8080');

=end original

  # "daemon"コマンドを開始する
  app->start('daemon', '-l', 'http://*:8080');

=head2 Reloading

(リロード)

=begin original

Your application will automatically reload itself if you start it with the
L<morbo> development web server, so you don't have to restart the server after
every change.

=end original

開発用サーバーのL<morbo>でアプリケーションを起動すれば、 アプリケーションは自動的にリロードされます。ソースコードを変更した後に毎回サーバを再起動させる必要はありません。

  $ morbo ./myapp.pl
  Server available at http://127.0.0.1:3000

=begin original

For more information about how to deploy your application see also
L<Mojolicious::Guides::Cookbook/"DEPLOYMENT">.

=end original

アプリケーションのデプロイ方法について詳しい情報は、 L<Mojolicious::Guides::Cookbook/"DEPLOYMENT">の項目を見てください。

=head2 Routes

(ルーティング(Routes))

=begin original

Routes are basically just fancy paths that can contain different kinds of
placeholders and usually lead to an action, if they match the path part of the
request URL. The first argument passed to all actions (C<$c>) is a
L<Mojolicious::Controller> object, containing both the HTTP request and
response.

=end original

ルーティング(routes)とは、一般的にいうと異なる種類のプレースホルダを含むことのできる仮想的なパスのことです。通常はアクションにつながっており、リクエストURLのパス部分にマッチしたときに実行されます。すべてのアクション (C<$c>) に渡される第一引数は、L<Mojolicious::Controller>のインスタンスです。これにはHTTPリクエストとレスポンスが含まれています。

  use Mojolicious::Lite;

=begin original

  # Route leading to an action that renders some text
  get '/foo' => sub {
    my $c = shift;
    $c->render(text => 'Hello World!');
  };

=end original

  # テキストをレンダリングするアクションへのルーティング
  get '/foo' => sub {
    my $c = shift;
    $c->render(text => 'Hello World!');
  };

  app->start;

=begin original

Response content is often generated by actions with
L<Mojolicious::Controller/"render">, but more about that later.

=end original

レスポンスコンテントの多くは L<Mojolicious::Controller/"render">を使ったアクションによって生成されます。詳しくは後ほど。

=head2 GET/POST parameters

(GET/POSTパラメーター)

=begin original

All C<GET> and C<POST> parameters sent with the request are accessible via
L<Mojolicious::Controller/"param">.

=end original

すべてのC<GET>とC<POST>パラメーターはL<Mojolicious::Controller/"param">を通じてアクセスできます。

  use Mojolicious::Lite;

  # /foo?user=sri
  get '/foo' => sub {
    my $c    = shift;
    my $user = $c->param('user');
    $c->render(text => "Hello $user.");
  };

  app->start;

=head2 Stash and templates

(スタッシュとテンプレート)

=begin original

The L<Mojolicious::Controller/"stash"> is used to pass data to templates, which
can be inlined in the C<DATA> section. A few stash values like C<template>,
C<text> and C<data> are reserved and will be used by
L<Mojolicious::Controller/"render"> to decide how a response should be
generated.

=end original

L<Mojolicious::Controller/"stash">はデータをテンプレートに渡すために利用します。テンプレートはC<DATA>セクションに埋め込むことができます。C<template>、C<text>、C<data>などのいくつかがスタッシュの値として予約されており、L<Mojolicious::Controller/"render">で使われて、レスポンスをどのように生成するかが決定されます。

  use Mojolicious::Lite;

=begin original

  # Route leading to an action that renders a template
  get '/foo' => sub {
    my $c = shift;
    $c->stash(one => 23);
    $c->render(template => 'magic', two => 24);
  };

=end original

  # テンプレートを描画するアクションに至るルート
  get '/foo' => sub {
    my $c = shift;
    $c->stash(one => 23);
    $c->render(template => 'magic', two => 24);
  };

  app->start;
  __DATA__

  @@ magic.html.ep
  The magic numbers are <%= $one %> and <%= $two %>.

=begin original

For more information about templates see also
L<Mojolicious::Guides::Rendering/"Embedded Perl">.

=end original

テンプレートについて詳しい情報は L<Mojolicious::Guides::Rendering/"Embedded Perl"> の項を見てください。

=head2 HTTP

=begin original

L<Mojolicious::Controller/"req"> and L<Mojolicious::Controller/"res"> give you
full access to all HTTP features and information.

=end original

L<Mojolicious::Controller/"req">とL<Mojolicious::Controller/"res"> を使って、HTTPの機能と情報のすべてに完全にアクセスすることができます。

  use Mojolicious::Lite;

=begin original

  # Access request information
  get '/agent' => sub {
    my $c    = shift;
    my $host = $c->req->url->to_abs->host;
    my $ua   = $c->req->headers->user_agent;
    $c->render(text => "Request by $ua reached $host.");
  };

=end original

  # リクエストの情報にアクセス
  get '/agent' => sub {
    my $c    = shift;
    my $host = $c->req->url->to_abs->host;
    my $ua   = $c->req->headers->user_agent;
    $c->render(text => "Request by $ua reached $host.");
  };

=begin original

  # Echo the request body and send custom header with response
  post '/echo' => sub {
    my $c = shift;
    $c->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    $c->render(data => $c->req->body);
  };

=end original

  # リクエストボディをエコーして、レスポンスのついたカスタムヘッダを送信
  post '/echo' => sub {
    my $c = shift;
    $c->res->headers->header('X-Bender' => 'Bite my shiny metal ass!');
    $c->render(data => $c->req->body);
  };

  app->start;

=begin original

You can test the more advanced examples right from the command line with
L<Mojolicious::Command::get>.

=end original

L<Mojolicious::Command::get>を使って、 コマンドラインからより発展的なサンプルをテストできます。

  $ ./myapp.pl get -v -M POST -c 'test' /echo

=head2 JSON

=begin original

JSON is the most commonly used data-interchange format for web services.
L<Mojolicious> loves JSON and comes with the possibly fastest pure-Perl
implementation L<Mojo::JSON> built right in, which is accessible through
L<Mojo::Message/"json"> as well as the reserved stash value C<json>.

=end original

JSONは、ウェブサービスでもっともよく使われるデータ交換フォーマットです。 L<Mojolicious>はJSONが大好きです。ピュアPerlの実装ではおそらく最速の L<Mojo::JSON> が組み込まれており、L<Mojo::Message/"json"> または予約済みスタッシュ値のC<json>によってアクセスできます。

  use Mojolicious::Lite;

=begin original

  # Modify the received JSON document and return it
  put '/reverse' => sub {
    my $c    = shift;
    my $hash = $c->req->json;
    $hash->{message} = reverse $hash->{message};
    $c->render(json => $hash);
  };

=end original

  # 受け取ったJSONドキュメントを変更して返す
  put '/reverse' => sub {
    my $c    = shift;
    my $hash = $c->req->json;
    $hash->{message} = reverse $hash->{message};
    $c->render(json => $hash);
  };

  app->start;

=begin original

You can send JSON documents from the command line with
L<Mojolicious::Command::get>.

=end original

コマンドラインからL<Mojolicious::Command::get>を使ってJSONドキュメントを送信できます。

  $ ./myapp.pl get -M PUT -c '{"message":"Hello Mojo!"}' /reverse

=head2 Built-in C<exception> and C<not_found> pages

(組み込みの例外(C<exception>)とノットファウンド(C<not_found>)ページ)

=begin original

During development you will encounter these pages whenever you make a mistake,
they are gorgeous and contain a lot of valuable information that will aid you
in debugging your application.

=end original

開発中、間違いを犯したときはいつでも、 このページに遭遇するでしょう。ここには、素晴らしい、アプリケーションのデバックに役立つ 情報がたくさん含まれています。

  use Mojolicious::Lite;

  # Not found (404)
  get '/missing' => sub { shift->render(template => 'does_not_exist') };

  # Exception (500)
  get '/dies' => sub { die 'Intentional error' };

  app->start;

=begin original

You can even use CSS selectors with L<Mojolicious::Command::get> to extract only
the information you're actually interested in.

=end original

L<Mojolicious::Command::get> でCSSセレクタを使えば、実際に知りたい情報だけを取り出すこともできます。

  $ ./myapp.pl get /dies '#error'

=begin original

And don't worry about revealing too much information on these pages, they are
only available during development, and will be replaced automatically with pages
that don't reveal any sensitive information in a production environment.

=end original

ページに情報が見えすぎるからといって心配しないでください。これが有効になるのは開発中だけです。プロダクション環境では、大切な情報が表示されないページに自動的に置き換わります。

=head2 Route names

(ルーティング名)

=begin original

All routes can have a name associated with them, this allows automatic template
detection and backreferencing with L<Mojolicious::Controller/"url_for">, on
which many methods and helpers like
L<Mojolicious::Plugin::TagHelpers/"link_to"> rely.

=end original

すべてのルーティング(routes)には名前を付けることができます。名前を付けることによってテンプレートの自動検出やL<Mojolicious::Controller/"url_for">による逆引きができるようになり、L<Mojolicious::Plugin::TagHelpers/"link_to">など、多くのヘルパーやメソッドがこれに基づいて動きます。

  use Mojolicious::Lite;

=begin original

  # Render the template "index.html.ep"
  get '/' => sub {
    my $c = shift;
    $c->render;
  } => 'index';

=end original

  # "index.html.ep"というテンプレートを描画
  get '/' => sub {
    my $c = shift;
    $c->render;
  } => 'index';

=begin original

  # Render the template "hello.html.ep"
  get '/hello';

=end original

  # "hello.html.ep"というテンプレートを描画
  get '/hello';

  app->start;
  __DATA__

  @@ index.html.ep
  <%= link_to Hello  => 'hello' %>.
  <%= link_to Reload => 'index' %>.

  @@ hello.html.ep
  Hello World!

=begin original

Nameless routes get an automatically generated one assigned that is simply
equal to the route itself without non-word characters.

=end original

名前がないルートには、自動生成されたルート名が割り当てられます。この名前は、ルート自身の名前からノンワード文字を除いたものと同じです。

=head2 Layouts

(レイアウト)

=begin original

Templates can have layouts too, you just select one with the helper
L<Mojolicious::Plugin::DefaultHelpers/"layout"> and place the result of the
current template with the helper
L<Mojolicious::Plugin::DefaultHelpers/"content">.

=end original

テンプレートにはレイアウトを持たせることができます。レイアウトはL<Mojolicious::Plugin::DefaultHelpers/"layout">ヘルパーを使って選択することができ、L<Mojolicious::Plugin::DefaultHelpers/"content">ヘルパーを使って現在のテンプレートの結果を入れることができます。

  use Mojolicious::Lite;

  get '/with_layout';

  app->start;
  __DATA__

  @@ with_layout.html.ep
  % title 'Green';
  % layout 'green';
  Hello World!

  @@ layouts/green.html.ep
  <!DOCTYPE html>
  <html>
    <head><title><%= title %></title></head>
    <body><%= content %></body>
  </html>

=begin original

The stash or helpers like L<Mojolicious::Plugin::DefaultHelpers/"title"> can be
used to pass additional data to the layout.

=end original

スタッシュやL<Mojolicious::Plugin::DefaultHelpers/"title">のようなヘルパーを使うと、追加のデータをレイアウトに渡せます。

=head2 Blocks

(ブロック)

=begin original

Template blocks can be used like normal Perl functions and are always delimited
by the C<begin> and C<end> keywords, they are the foundation for many helpers.

=end original

テンプレートブロックは通常のPerl関数のように利用でき、常にC<begin>とC<end>というキーワードで区切ります。これは多くのヘルパーの基盤になっています。

  use Mojolicious::Lite;

  get '/with_block' => 'block';

  app->start;
  __DATA__

  @@ block.html.ep
  % my $link = begin
    % my ($url, $name) = @_;
    Try <%= link_to $url => begin %><%= $name %><% end %>.
  % end
  <!DOCTYPE html>
  <html>
    <head><title>Sebastians frameworks</title></head>
    <body>
      %= $link->('http://mojolicious.org', 'Mojolicious')
      %= $link->('http://catalystframework.org', 'Catalyst')
    </body>
  </html>

=head2 Helpers

(ヘルパー)

=begin original

Helpers are little functions you can create with the keyword
L<Mojolicious::Lite/"helper"> and reuse throughout your whole application, from
actions to templates.

=end original

ヘルパーは L<Mojolicious::Lite/"helper"> キーワードで作ることができる小さな関数です。アクションからテンプレートまでアプリケーション全体において利用することができます。

  use Mojolicious::Lite;

=begin original

  # A helper to identify visitors
  helper whois => sub {
    my $c     = shift;
    my $agent = $c->req->headers->user_agent || 'Anonymous';
    my $ip    = $c->tx->remote_address;
    return "$agent ($ip)";
  };

=end original

  # 訪問者を特定するヘルパー
  helper whois => sub {
    my $c     = shift;
    my $agent = $c->req->headers->user_agent || 'Anonymous';
    my $ip    = $c->tx->remote_address;
    return "$agent ($ip)";
  };

=begin original

  # Use helper in action and template
  get '/secret' => sub {
    my $c    = shift;
    my $user = $c->whois;
    $c->app->log->debug("Request from $user");
  };

=end original

  # アクションとテンプレートのなかでヘルパーを使う
  get '/secret' => sub {
    my $c    = shift;
    my $user = $c->whois;
    $c->app->log->debug("Request from $user");
  };

  app->start;
  __DATA__

  @@ secret.html.ep
  We know who you are <%= whois %>.

=begin original

A list of all built-in ones can be found in
L<Mojolicious::Plugin::DefaultHelpers> and L<Mojolicious::Plugin::TagHelpers>.

=end original

すべての組み込みヘルパーのリストは、 L<Mojolicious::Plugin::DefaultHelpers> と L<Mojolicious::Plugin::TagHelpers>にあります。

=head2 Placeholders

(プレースホルダー)

=begin original

Route placeholders allow capturing parts of a request path until a C</> or C<.>
separator occurs, similar to the regular expression C<([^/.]+)>. Results are
accessible via L<Mojolicious::Controller/"stash"> and
L<Mojolicious::Controller/"param">.

=end original

ルーティング(routes)プレースホルダを使用すると、区切り文字の / あるいは . が出現するまでの部分を、リクエストパスからキャプチャできます。結果はL<Mojolicious::Controller/"stash">とC<param>を通じて利用できます。

  use Mojolicious::Lite;

  # /foo/test
  # /foo/test123
  get '/foo/:bar' => sub {
    my $c   = shift;
    my $bar = $c->stash('bar');
    $c->render(text => "Our :bar placeholder matched $bar");
  };

  # /testsomething/foo
  # /test123something/foo
  get '/<:bar>something/foo' => sub {
    my $c   = shift;
    my $bar = $c->param('bar');
    $c->render(text => "Our :bar placeholder matched $bar");
  };

  app->start;

=begin original

To separate them from the surrounding text, you can surround your placeholders
with C<E<lt>> and C<E<gt>>, which also makes the colon prefix optional.

=end original

プレースホルダーを周囲の文字列と区別するためには、 C<E<lt>> と C<E<gt>> で囲みます。こうした場合、プレフィックスのコロンはオプションになります。

=head2 Relaxed Placeholders

(リラックスプレースホルダー)

=begin original

Relaxed placeholders allow matching of everything until a C</> occurs, similar
to the regular expression C<([^/]+)>.

=end original

リラックスプレースホルダーを使えば、 C</>が出現するまでのすべてにマッチさせることができます。これは正規表現のC<([^/]+)>に似ています。

  use Mojolicious::Lite;

  # /hello/test
  # /hello/test.html
  get '/hello/#you' => 'groovy';

  app->start;
  __DATA__

  @@ groovy.html.ep
  Your name is <%= $you %>.

=head2 Wildcard placeholders

(ワイルドカードプレースホルダー)

=begin original

Wildcard placeholders allow matching absolutely everything, including C</> and
C<.>, similar to the regular expression C<(.+)>.

=end original

ワイルドカードプレースホルダを使用すると、C</>とC<.>を含むすべてにマッチさせることができます。正規表現のC<(.+)>に似ています。

  use Mojolicious::Lite;

=begin original

  # /hello/test
  # /hello/test123
  # /hello/test.123/test/123
  get '/hello/*you' => 'groovy';

=end original

  use Mojolicious::Lite;
  # /hello/test123
  # /hello/test.123/test/123
  get '/hello/*you' => 'groovy';

  app->start;
  __DATA__

  @@ groovy.html.ep
  Your name is <%= $you %>.

=head2 HTTP methods

(HTTPメソッド)

=begin original

Routes can be restricted to specific request methods with different keywords
like L<Mojolicious::Lite/"get"> and L<Mojolicious::Lite/"any">.

=end original

ルーティングは L<Mojolicious::Lite//"get"> や L<Mojolicious::Lite/"any">といったキーワードによって特定のリクエストメソッドに限定できます。

  use Mojolicious::Lite;

  # GET /hello
  get '/hello' => sub {
    my $c = shift;
    $c->render(text => 'Hello World!');
  };

  # PUT /hello
  put '/hello' => sub {
    my $c    = shift;
    my $size = length $c->req->body;
    $c->render(text => "You uploaded $size bytes to /hello.");
  };

  # GET|POST|PATCH /bye
  any ['GET', 'POST', 'PATCH'] => '/bye' => sub {
    my $c = shift;
    $c->render(text => 'Bye World!');
  };

  # * /whatever
  any '/whatever' => sub {
    my $c      = shift;
    my $method = $c->req->method;
    $c->render(text => "You called /whatever with $method.");
  };

  app->start;

=head2 Optional placeholders

(プレースホルダーのオプション)

=begin original

All placeholders require a value, but by assigning them default values you can
make capturing optional.

=end original

すべてのプレースホルダーは値を必要としますが、 プレースホルダーにデフォルト値を設定することにより キャプチャをオプショナルなものにすることができます。

  use Mojolicious::Lite;

  # /hello
  # /hello/Sara
  get '/hello/:name' => {name => 'Sebastian', day => 'Monday'} => sub {
    my $c = shift;
    $c->render(template => 'groovy', format => 'txt');
  };

  app->start;
  __DATA__

  @@ groovy.txt.ep
  My name is <%= $name %> and it is <%= $day %>.

=begin original

Default values that don't belong to a placeholder simply get merged into the
stash all the time.

=end original

プレースホルダーに所属しないデフォルト値は、 いつでも単純にスタッシュにマージされます。

=head2 Restrictive placeholders

(制約的なプレースホルダー)

=begin original

A very easy way to make placeholders more restrictive are alternatives, you just
make a list of possible values.

=end original

プレースホルダーにより多くの制約を加えるには、選択肢を使うのが一番簡単です。候補となる値のリストを作るだけでOKです。

  use Mojolicious::Lite;

  # /test
  # /123
  any '/:foo' => [foo => ['test', '123']] => sub {
    my $c   = shift;
    my $foo = $c->param('foo');
    $c->render(text => "Our :foo placeholder matched $foo");
  };

  app->start;

=begin original

All placeholders get compiled to a regular expression internally, this process
can also be customized. Just make sure not to use C<^> and C<$>, or capturing
groups C<(...)>, non-capturing groups C<(?:...)> are fine though.

=end original

すべてのプレースホルダーは、内部で正規表現にコンパイルされます。この処理はカスタマイズすることもできます。C<^>とC<$>を使ったり、C<(...)>でグループのキャプチャは行わないでください。けれどもキャプチャしないC<(?:...)>は大丈夫です。

  use Mojolicious::Lite;

  # /1
  # /123
  any '/:bar' => [bar => qr/\d+/] => sub {
    my $c   = shift;
    my $bar = $c->param('bar');
    $c->render(text => "Our :bar placeholder matched $bar");
  };

  app->start;

=begin original

You can take a closer look at all the generated regular expressions with the
command L<Mojolicious::Command::routes>.

=end original

生成されたすべての正規表現は、 L<Mojolicious::Command::routes>で詳しく確認することができます。

  $ ./myapp.pl routes -v

=head2 Under

(アンダー (Under))

=begin original

Authentication and code shared between multiple routes can be realized easily
with routes generated by L<Mojolicious::Lite/"under">. All following routes are
only evaluated if the callback returned a true value.

=end original

認証や複数のルーティングの間でコードを共有するためには、L<Mojolicious::Lite/"under">構文を使う簡単です。以降のすべてのルーティングは、underコールバックが真値を返したときだけ評価されます。

  use Mojolicious::Lite;

=begin original

  # Authenticate based on name parameter
  under sub {
    my $c = shift;

=end original

  # nameパラメータを元にした認証
  under sub {
    my $c = shift;

=begin original

    # Authenticated
    my $name = $c->param('name') || '';
    return 1 if $name eq 'Bender';

=end original

    # 認証された
    my $name = $c->param('name') || '';
    return 1 if $name eq 'Bender';

=begin original

    # Not authenticated
    $c->render(template => 'denied');
    return undef;
  };

=end original

    # 認証されなかった
    $c->render(template => 'denied');
    return undef;
  };

  # Only reached when authenticated
  get '/' => 'index';

  app->start;
  __DATA__

  @@ denied.html.ep
  You are not Bender, permission denied.

  @@ index.html.ep
  Hi Bender.

=begin original

Prefixing multiple routes is another good use for it.

=end original

複数のルーティングをあらかじめ決めるために使うのもまた良い利用方法です。

  use Mojolicious::Lite;

  # /foo
  under '/foo';

  # /foo/bar
  get '/bar' => {text => 'foo bar'};

  # /foo/baz
  get '/baz' => {text => 'foo baz'};

  # / (reset)
  under '/' => {msg => 'whatever'};

  # /bar
  get '/bar' => {inline => '<%= $msg %> works'};

  app->start;

=begin original

You can also group related routes with L<Mojolicious::Lite/"group">, which
allows nesting of routes generated with L<Mojolicious::Lite/"under">.

=end original

L<Mojolicious::Lite/"group">で関連するルーティングをグループ化(C<group>)することもできます。これによって、L<Mojolicious::Lite/"under">で生成したルートをネストできるようになります。

  use Mojolicious::Lite;

=begin original

  # Global logic shared by all routes
  under sub {
    my $c = shift;
    return 1 if $c->req->headers->header('X-Bender');
    $c->render(text => "You're not Bender.");
    return undef;
  };

=end original

  # すべてのルートで共有されるグローバルなロジック
  under sub {
    my $c = shift;
    return 1 if $c->req->headers->header('X-Bender');
    $c->render(text => "You're not Bender.");
    return undef;
  };

=begin original

  # Admin section
  group {

=end original

  # Adminの部分
  group {

=begin original

    # Local logic shared only by routes in this group
    under '/admin' => sub {
      my $c = shift;
      return 1 if $c->req->headers->header('X-Awesome');
      $c->render(text => "You're not awesome enough.");
      return undef;
    };

=end original

    # グループ内のルートだけに共有されるローカルなロジック
    under '/admin' => sub {
      my $c = shift;
      return 1 if $c->req->headers->header('X-Awesome');
      $c->render(text => "You're not awesome enough.");
      return undef;
    };

    # GET /admin/dashboard
    get '/dashboard' => {text => 'Nothing to see here yet.'};
  };

  # GET /welcome
  get '/welcome' => {text => 'Hi Bender.'};

  app->start;

=head2 Formats

(フォーマット)

=begin original

Formats can be automatically detected from file extensions like C<.html>, they
are used to find the right template and generate the correct C<Content-Type>
header.

=end original

フォーマット（formats）は、C<.html>などのファイル拡張子によって自動的に検出されます。フォーマットは正しいテンプレートを探したり、正確なC<Content-Type>ヘッダーを生成するために使用されます。

  use Mojolicious::Lite;

  # /detection
  # /detection.html
  # /detection.txt
  get '/detection' => sub {
    my $c = shift;
    $c->render(template => 'detected');
  };

  app->start;
  __DATA__

  @@ detected.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>Detected</title></head>
    <body>HTML was detected.</body>
  </html>

  @@ detected.txt.ep
  TXT was detected.

=begin original

The default format is C<html>, and restrictive placeholders can be used to
limit possible values.

=end original

デフォルトのフォーマットは C<html>です。プレースホルダで制限すれば、取りうる値を限定できます。

  use Mojolicious::Lite;

  # /hello.json
  # /hello.txt
  get '/hello' => [format => ['json', 'txt']] => sub {
    my $c = shift;
    return $c->render(json => {hello => 'world'})
      if $c->stash('format') eq 'json';
    $c->render(text => 'hello world');
  };

  app->start;

=begin original

Or you can just disable format detection with a special type of restrictive
placeholder.

=end original

フォーマットの検知は、特別なタイプのプレースホルダーを使うことで無効にすることもできます。

  use Mojolicious::Lite;

  # /hello
  get '/hello' => [format => 0] => {text => 'No format detection.'};

=begin original

  # Disable detection and allow the following routes to re-enable it on demand
  under [format => 0];

=end original

  # 検出を無効にして、以降のルートにおいて必要であれば再び有効にする
  under [format => 0];

  # /foo
  get '/foo' => {text => 'No format detection again.'};

  # /bar.txt
  get '/bar' => [format => 'txt'] => {text => ' Just one format.'};

  app->start;

=head2 Content negotiation

(コンテントネゴシエーション)

=begin original

For resources with different representations and that require truly RESTful
content negotiation you can also use
L<Mojolicious::Plugin::DefaultHelpers/"respond_to">.

=end original

異なる方法で表現されるリソースや本当にRESTfulなコンテントネゴーシエーションが必要な場合は、L<Mojolicious::Plugin::DefaultHelpers/"respond_to">を使用することもできます。

  use Mojolicious::Lite;

  # /hello (Accept: application/json)
  # /hello (Accept: application/xml)
  # /hello.json
  # /hello.xml
  # /hello?format=json
  # /hello?format=xml
  get '/hello' => sub {
    my $c = shift;
    $c->respond_to(
      json => {json => {hello => 'world'}},
      xml  => {text => '<hello>world</hello>'},
      any  => {data => '', status => 204}
    );
  };

  app->start;

=begin original

MIME type mappings can be extended or changed easily with
L<Mojolicious/"types">.

=end original

MIMEタイプのマッピングは、L<Mojolicious/"types">によって拡張したり、変更したりすることができます。

  app->types->type(rdf => 'application/rdf+xml');

=head2 Static files

(静的ファイル)

=begin original

Similar to templates, but with only a single file extension and optional Base64
encoding, static files can be inlined in the C<DATA> section and are served
automatically.

=end original

テンプレートに似て、静的ファイルはC<DATA>セクションの中にインラインで記述することができ、自動的にサーブされます。ただし、使える拡張子が1種類に限られるのと、Base64エンコーディングが使える点が異なります。

  use Mojolicious::Lite;

  app->start;
  __DATA__

  @@ something.js
  alert('hello!');

  @@ test.txt (base64)
  dGVzdCAxMjMKbGFsYWxh

=begin original

External static files are not limited to a single file extension and will be
served automatically from a C<public> directory if it exists.

=end original

外部に置いた静的ファイルは、拡張子が1種類に制限されず、C<public>ディレクトリが存在すればそこから自動的にサーブされます。

  $ mkdir public
  $ mv something.js public/something.js
  $ mv mojolicious.tar.gz public/mojolicious.tar.gz

=begin original

Both have a higher precedence than routes for C<GET> and C<HEAD> requests.
Content negotiation with C<Range>, C<If-None-Match> and C<If-Modified-Since>
headers is supported as well and can be tested very easily with
L<Mojolicious::Command::get>.

=end original

両方とも優先度はC<GET>、C<HEAD>リクエストのルーティングよりも高くなります。 C<Range>、C<If-None-Match>、C<If-Modified-Since>ヘッダー によるコンテンツネゴシエーションにも対応していて、 L<Mojolicious::Command::get>で簡単にテストできます。

  $ ./myapp.pl get /something.js -v -H 'Range: bytes=2-4'

=head2 External templates

(外部テンプレート)

=begin original

External templates will be searched by the renderer in a C<templates> directory
if it exists.

=end original

外部テンプレートは、レンダラによってC<templates> ディレクトリから検索されます。

  $ mkdir -p templates/foo
  $ echo 'Hello World!' > templates/foo/bar.html.ep

=begin original

They have a higher precedence than templates in the C<DATA> section.

=end original

これらはC<DATA>セクションにあるテンプレートよりも優先されます。

  use Mojolicious::Lite;

=begin original

  # Render template "templates/foo/bar.html.ep"
  any '/external' => sub {
    my $c = shift;
    $c->render(template => 'foo/bar');
  };

=end original

  # "templates/foo/bar.html.ep"というテンプレートを描画する
  any '/external' => sub {
    my $c = shift;
    $c->render(template => 'foo/bar');
  };

  app->start;

=head2 Home

(ホーム)

=begin original

You can use L<Mojolicious/"home"> to interact with the directory your
application considers its home. This is the directory it will search for
C<public> and C<templates> directories, but you can use it to store all sorts of
application specific data.

=end original

L<Mojolicious/"home"> を使うと、アプリケーションがホームとしているディレクトリにアクセスできます。ホームディレクトリは、アプリケーションがC<public>, C<templates>ディレクトリを検索する場所です。ここにあらゆる種類のアプリケーションデータを保存することもできます。

  $ mkdir cache
  $ echo 'Hello World!' > cache/hello.txt

=begin original

There are many useful methods L<Mojo::Home> inherits from L<Mojo::File>, like
L<Mojo::File/"child"> and L<Mojo::File/"slurp">, that will help you keep your
application portable across many different operating systems.

=end original

L<Mojo::Home> には L<Mojo::File>から継承した便利なメソッドがたくさんあります。たとえば、L<Mojo::File/"child">やL<Mojo::File/"slurp">は、アプリケーションを様々なオペレーティングシステムにまたがって使用できるようにしています。

  use Mojolicious::Lite;

=begin original

  # Load message into memory
  my $hello = app->home->child('cache', 'hello.txt')->slurp;

=end original

  # メッセージをメモリに読み込む
  my $hello = app->home->child('cache', 'hello.txt')->slurp;

=begin original

  # Display message
  get '/' => sub {
    my $c = shift;
    $c->render(text => $hello);
  };

=end original

  # メッセージを表示する
  get '/' => sub {
    my $c = shift;
    $c->render(text => $hello);
  };

=begin original

You can also introspect your application from the command line with
L<Mojolicious::Command::eval>.

=end original

L<Mojolicious::Command::eval> を使うことでも、コマンドラインからアプリケーションを検証できます。

  $ ./myapp.pl eval -v 'app->home'

=head2 Conditions

(条件)

=begin original

Conditions such as C<agent> and C<host> from
L<Mojolicious::Plugin::HeaderCondition> allow even more powerful route
constructs.

=end original

L<Mojolicious::Plugin::HeaderCondition> を使用すれば、より強力なルーティングを構築できます。

  use Mojolicious::Lite;

  # Firefox
  get '/foo' => (agent => qr/Firefox/) => sub {
    my $c = shift;
    $c->render(text => 'Congratulations, you are using a cool browser.');
  };

  # Internet Explorer
  get '/foo' => (agent => qr/Internet Explorer/) => sub {
    my $c = shift;
    $c->render(text => 'Dude, you really need to upgrade to Firefox.');
  };

  # http://mojolicious.org/bar
  get '/bar' => (host => 'mojolicious.org') => sub {
    my $c = shift;
    $c->render(text => 'Hello Mojolicious.');
  };

  app->start;

=head2 Sessions

(セッション)

=begin original

Cookie-based sessions just work out of the box, as soon as you start using them
through the helper L<Mojolicious::Plugin::DefaultHelpers/"session">. Just be
aware that all session data gets serialized with L<Mojo::JSON> and stored
client-side, with a cryptographic signature to prevent tampering.

=end original

L<Mojolicious::Plugin::DefaultHelpers/"session">ヘルパーを使うとすぐに、クッキーをベースとしたセッションが機能します。すべてのセッションデータはL<Mojo::JSON>でシリアライズされ、 クライアントサイドに保存されることを意識しておいてください。改ざんを防ぐために、暗号化された署名がついています。

  use Mojolicious::Lite;

=begin original

  # Access session data in action and template
  get '/counter' => sub {
    my $c = shift;
    $c->session->{counter}++;
  };

=end original

  # アクションとテンプレートの中のセッションデータへのアクセス
  get '/counter' => sub {
    my $c = shift;
    $c->session->{counter}++;
  };

  app->start;
  __DATA__

  @@ counter.html.ep
  Counter: <%= session 'counter' %>

=begin original

Note that you should use custom L<Mojolicious/"secrets"> to make signed cookies
really tamper resistant.

=end original

署名付き(signed)クッキーを本当に改ざんできなくするには、L<Mojolicious/"secrets">をカスタムして使用してください。

  app->secrets(['My secret passphrase here']);

=head2 File uploads

(ファイルアップロード)

=begin original

All files uploaded via C<multipart/form-data> request are automatically
available as L<Mojo::Upload> objects from L<Mojolicious::Controller/"param">.
And you don't have to worry about memory usage, because all files above 250KiB
will be automatically streamed into a temporary file. To build HTML forms more
efficiently, you can also use tag helpers like
L<Mojolicious::Plugin::TagHelpers/"form_for">.

=end original

ファイルは、C<multipart/form-data>リクエストを通してアップロードされると、自動的に L<Mojolicious::Controller/"param">からL<Mojo::Upload>のインスタンスとして利用可能になります。 メモリの使用率を気にする必要はありません。C<250KB>を超えるすべてのファイルは自動的に一時ファイルに保存されるからです。HTMLフォームを効率的に構築するために、 L<Mojolicious::Plugin::TagHelpers/"form_for">のような タグヘルパーを使うこともできます。

  use Mojolicious::Lite;

=begin original

  # Upload form in DATA section
  get '/' => 'form';

=end original

  # DATAセクションのformをアップロード
  get '/' => 'form';

=begin original

  # Multipart upload handler
  post '/upload' => sub {
    my $c = shift;

=end original

  # Multipartのアップロードのハンドラ
  post '/upload' => sub {
    my $c = shift;

=begin original

    # Check file size
    return $c->render(text => 'File is too big.', status => 200)
      if $c->req->is_limit_exceeded;

=end original

    # ファイルサイズのチェック
    return $c->render(text => 'File is too big.', status => 200)
      if $c->req->is_limit_exceeded;

=begin original

    # Process uploaded file
    return $c->redirect_to('form') unless my $example = $c->param('example');
    my $size = $example->size;
    my $name = $example->filename;
    $c->render(text => "Thanks for uploading $size byte file $name.");
  };

=end original

    # アップロードしたファイルを処理
    return $c->redirect_to('form') unless my $example = $c->param('example');
    my $size = $example->size;
    my $name = $example->filename;
    $c->render(text => "Thanks for uploading $size byte file $name.");
  };

  app->start;
  __DATA__

  @@ form.html.ep
  <!DOCTYPE html>
  <html>
    <head><title>Upload</title></head>
    <body>
      %= form_for upload => (enctype => 'multipart/form-data') => begin
        %= file_field 'example'
        %= submit_button 'Upload'
      % end
    </body>
  </html>

=begin original

To protect you from excessively large files there is also a limit of 16MiB by
default, which you can tweak with the attribute
L<Mojolicious/"max_request_size">.

=end original

極端に大きなファイルから保護するために、デフォルトでC<16MB>の制限があります。サイズはL<Mojolicious/"max_request_size"> 属性で変更できます。

=begin original

  # Increase limit to 1GiB
  app->max_request_size(1073741824);

=end original

  # 制限を1GBに増やす
  app->max_request_size(1073741824);

=head2 User agent

(ユーザーエージェント)

=begin original

With L<Mojo::UserAgent>, which is available through the helper
L<Mojolicious::Plugin::DefaultHelpers/"ua">, there's a full featured HTTP and
WebSocket user agent built right in. Especially in combination with
L<Mojo::JSON> and L<Mojo::DOM> this can be a very powerful tool.

=end original

L<Mojo::UserAgent>は、完全に機能を備えたHTTP 1.1とWebSocketの組み込みのユーザーエージェントです。L<Mojolicious::Plugin::DefaultHelpers/"ua">を通して利用できます。特にL<Mojo::JSON>とL<Mojo::DOM>の組み合わせはとても強力なツールになります。

  use Mojolicious::Lite;

=begin original

  # Blocking
  get '/headers' => sub {
    my $c   = shift;
    my $url = $c->param('url') || 'https://mojolicious.org';
    my $dom = $c->ua->get($url)->result->dom;
    $c->render(json => $dom->find('h1, h2, h3')->map('text')->to_array);
  };

=end original

  # ブロッキング
  get '/headers' => sub {
    my $c   = shift;
    my $url = $c->param('url') || 'https://mojolicious.org';
    my $dom = $c->ua->get($url)->result->dom;
    $c->render(json => $dom->find('h1, h2, h3')->map('text')->to_array);
  };

=begin original

  # Non-blocking
  get '/title' => sub {
    my $c = shift;
    $c->ua->get('mojolicious.org' => sub {
      my ($ua, $tx) = @_;
      $c->render(data => $tx->result->dom->at('title')->text);
    });
  };

=end original

  # ノンブロッキング
  get '/title' => sub {
    my $c = shift;
    $c->ua->get('mojolicious.org' => sub {
      my ($ua, $tx) = @_;
      $c->render(data => $tx->result->dom->at('title')->text);
    });
  };

=begin original

  # Concurrent non-blocking
  get '/titles' => sub {
    my $c  = shift;
    my $mojo = $c->ua->get_p('https://mojolicious.org');
    my $cpan = $c->ua->get_p('https://metacpan.org');
    Mojo::Promise->all($mojo, $cpan)->then(sub {
      my ($mojo, $cpan) = @_;
      $c->render(json => {
        mojo => $mojo->[0]->result->dom->at('title')->text,
        cpan => $cpan->[0]->result->dom->at('title')->text
      });
    })->wait;
  };

=end original

  # 並列のノンブロッキング
  get '/titles' => sub {
    my $c  = shift;
    my $mojo = $c->ua->get_p('https://mojolicious.org');
    my $cpan = $c->ua->get_p('https://metacpan.org');
    Mojo::Promise->all($mojo, $cpan)->then(sub {
      my ($mojo, $cpan) = @_;
      $c->render(json => {
        mojo => $mojo->[0]->result->dom->at('title')->text,
        cpan => $cpan->[0]->result->dom->at('title')->text
      });
    })->wait;
  };

  app->start;

=begin original

For more information about the user agent see also
L<Mojolicious::Guides::Cookbook/"USER AGENT">.

=end original

ユーザーエージェントについてより詳しい情報は、L<Mojolicious::Guides::Cookbook/"USER AGENT">の項目にあります。

=head2 WebSockets

(WebSocket)

=begin original

WebSocket applications have never been this simple before. Just receive
messages by subscribing to events such as
L<Mojo::Transaction::WebSocket/"json"> with L<Mojolicious::Controller/"on"> and
return them with L<Mojolicious::Controller/"send">.

=end original

WebSocketアプリケーションはこれまでに見たこともないくらい簡単です。L<Mojo::Transaction::WebSocket/"json">と同じイベントを、L<Mojolicious::Controller/"on">を使って購読することによってメッセージを受信できます。メッセージを送信するには L<Mojolicious::Controller/"send">を使います。

  use Mojolicious::Lite;

  websocket '/echo' => sub {
    my $c = shift;
    $c->on(json => sub {
      my ($c, $hash) = @_;
      $hash->{msg} = "echo: $hash->{msg}";
      $c->send({json => $hash});
    });
  };

  get '/' => 'index';

  app->start;
  __DATA__

  @@ index.html.ep
  <!DOCTYPE html>
  <html>
    <head>
      <title>Echo</title>
      <script>
        var ws = new WebSocket('<%= url_for('echo')->to_abs %>');
        ws.onmessage = function (event) {
          document.body.innerHTML += JSON.parse(event.data).msg;
        };
        ws.onopen = function (event) {
          ws.send(JSON.stringify({msg: 'I ♥ Mojolicious!'}));
        };
      </script>
    </head>
  </html>

=begin original

For more information about real-time web features see also
L<Mojolicious::Guides::Cookbook/"REAL-TIME WEB">.

=end original

リアルタイムウェブ機能についてのより詳しい情報は、L<Mojolicious::Guides::Cookbook/"REAL-TIME WEB">にあります。

=head2 Mode

(モード)

=begin original

You can use the L<Mojo::Log> object from L<Mojolicious/"log"> to portably
collect debug messages and automatically disable them later in a production
setup by changing the L<Mojolicious> operating mode, which can also be retrieved
from the attribute L<Mojolicious/"mode">.

=end original

ポータブルにデバッグメッセージを収集するために、L<Mojolicious/"log">メソッドでL<Mojo::Log>オブジェクトを利用できます。L<Mojolicious>の処理モードを変更することによって、後のプロダクション用の設定においてデバッグを自動的に無効化することができます。これはL<Mojolicious/"mode">属性によって読み取り可能です。

  use Mojolicious::Lite;

=begin original

  # Prepare mode specific message during startup
  my $msg = app->mode eq 'development' ? 'Development!' : 'Something else!';

=end original

  # startupの間にモードに合ったメッセージを準備する
  my $msg = app->mode eq 'development' ?'Development!' : 'Something else!';

  get '/' => sub {
    my $c = shift;
    $c->app->log->debug('Rendering mode specific message');
    $c->render(text => $msg);
  };

  app->log->debug('Starting application');
  app->start;

=begin original

The default operating mode will usually be C<development> and can be changed
with command line options or the C<MOJO_MODE> and C<PLACK_ENV> environment
variables. A mode other than C<development> will raise the log level from
C<debug> to C<info>.

=end original

デフォルトの処理モードは通常 C<development>ですが、コマンドラインオプションか C<MOJO_MODE>あるいはC<PLACK_ENV>環境変数によって変更することもできます。C<development>以外のモードでは、ログレベルがC<debug>からC<info>に上がります。

  $ ./myapp.pl daemon -m production

=begin original

All messages will be written to C<STDERR> or a C<log/$mode.log> file if a
C<log> directory exists.

=end original

すべてのメッセージはC<STDERR>に出力されるか、 C<log>ディレクトリが存在する場合はC<log/$mode.log>に出力されます。

  $ mkdir log

=begin original

Mode changes also affect a few other aspects of the framework, such as the
built-in C<exception> and C<not_found> pages. Once you switch modes from
C<development> to C<production>, no sensitive information will be revealed on
those pages anymore.

=end original

モードの変更は、C<exception>やC<not_found>テンプレートなどのフレームワークのその他の面に影響します。モードをC<development>からC<production>に切り替えると 、例外ページに機密情報が表示されなくなります。

=head2 Testing

(テスト)

=begin original

Testing your application is as easy as creating a C<t> directory and filling it
with normal Perl tests like C<t/basic.t>, which can be a lot of fun thanks to
L<Test::Mojo>.

=end original

アプリケーションをテストするのはとても簡単です。C<t>ディレクトリを作成して 普通のPerlの単体テストを書くだけです。L<Test::Mojo>のおかげで、 とても楽しいです。

  use Test::More;
  use Mojo::File 'path';
  use Test::Mojo;

  # Portably point to "../myapp.pl"
  my $script = path(__FILE__)->dirname->sibling('myapp.pl');

  my $t = Test::Mojo->new($script);
  $t->get_ok('/')->status_is(200)->content_like(qr/Funky/);

  done_testing();

=begin original

Just run your tests with L<prove>.

=end original

テストはL<prove>で実行します。

  $ prove -l -v
  $ prove -l -v t/basic.t

=head1 MORE

(もっと)

=begin original

You can continue with L<Mojolicious::Guides> now or take a look at the
L<Mojolicious wiki|http://github.com/mojolicious/mojo/wiki>, which contains a
lot more documentation and examples by many different authors.

=end original

さあ、L<Mojolicious::Guides> を続けるか、L<Mojolicious wiki|http://github.com/mojolicious/mojo/wiki>を見てみましょう。多くの著者がたくさんのドキュメントやサンプルを書いています。

=head1 SUPPORT

(サポート)

=begin original

If you have any questions the documentation might not yet answer, don't
hesitate to ask on the
L<mailing list|http://groups.google.com/group/mojolicious> or the official IRC
channel C<#mojo> on C<irc.freenode.net> (L<chat
now!|https://kiwiirc.com/nextclient/#irc://irc.freenode.net/mojo?nick=guest-?>).

=end original

このドキュメントでわからない部分があれば、 L<mailing list|http://groups.google.com/group/mojolicious> かC<irc.freenode.net> (L<chat
now!|https://kiwiirc.com/nextclient/#irc://irc.freenode.net/mojo?nick=guest-?>)の公式IRCチャンネル C<#mojo> まで気軽に質問してください。

=begin meta

Translate: 木本裕紀
Translate: 前山将人
Update: SHIRAKATA Kentaro <argrath@ub32.org> (8.12)

=end meta

=cut

